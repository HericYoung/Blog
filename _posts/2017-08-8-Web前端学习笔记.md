---
layout: post
title: Web前端学习笔记
description: \[o_o\]只针对个人觉得需要记录的知识点进行记录，不适合用作前端的系统学习
category: Programming
tags: []
image: 
    feature: 
---

1.[Html](#html)<br>
2.[CSS](#css)<br>

# Html {#html}
&emsp;&emsp;HTML是英语HyperText Markup Language的缩写，超文本标记语言。<br>
&emsp;&emsp;html本质上和txt没有任何区别，他们都是纯文本文件。<br>

&emsp;&emsp;现在的业界的标准，网页技术严格的三层分离：html就是负责描述页面的语义；css负责描述页面的样式；js负责描述页面的动态效果的。<br>
&emsp;&emsp;HTML是负责描述文档语义的语言,除了语义，其他什么都没有。<br>

```
    <html>
        <head>
            
        </head>
        <body>
            
        </body>
    </html>
```
&emsp;&emsp;网页的最外层的标签对儿是`<html></html>`标签对儿，里面有两部分，分别是head和body。<br>
&emsp;&emsp;head标签中，描述网页的配置；body中的内容，才是用户可以看见的内容。<br><br><br>
```
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
        <head>
          <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
          <title>标题</title>
        </head>
        <body>
          
        </body>
    </html>
```
&emsp;&emsp;第1行，就是网页的声明头，术语叫做DocType Defintion，文档类型定义，简称DTD。这行语句非常的复杂，里面暗含了一个网址。W3C就是出web规范的组织机构。html、css、js的规范都是W3C定义发布的。world wide web coalition , 国际万维网联盟。网页声明头可以告诉浏览器，这是一个什么标准的页面。<br>
&emsp;&emsp;第2行，是最大的html标签，所有的网页内容，都要包裹在这个标签对儿里面。
我们发现，html标签中，有两个属性：<br>
&emsp;&emsp;`xmlns="http://www.w3.org/1999/xhtml" `,命名空间，就是一个规范；<br>
&emsp;&emsp;&emsp;&emsp;`xml:lang="en" `,语言是英语<br>
&emsp;&emsp;第3行，就是head标签，就是配置。<br>
&emsp;&emsp;第4行，`<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> `字符集的配置<br>
&emsp;&emsp;第5行，`<title>标题</title>`，网页的标题，可以显示在浏览器的标签栏中。<br>
&emsp;&emsp;第7行，body标签就是网页的内容，用户能够看见。<br>

- - - 
### 文档声明头
```
    <!DOCTYPE ……
```
&emsp;&emsp;Html文件开头的语句。<br>
&emsp;&emsp;这一行，就是文档声明头，DocType Declaration。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。<br>
&emsp;&emsp;HTML4.01版本是IE6开始兼容的。HTML5是IE9开开始兼容的。但是IE6、7、8这些浏览器还不能过早的淘汰，所以这几年网页还是应该用HTML4.01来制作。后面将知道手机、移动端的网页，就可以使用HTML5了。<br>

&emsp;&emsp;HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下面）：<br>
&emsp;&emsp;HTML4.01里面规定了普通、XHTML两大种规范。<br>
总结一下，一共有6种DTD，说白了，HTML第一行语句一共有6种：<br>

| 大规范 | 小规范 |
| HTML4.01 | Strict:严格的，体现在一些标签不能使用，比如u<br>Transitional:普通的<br>Frameset:带有框架的页面 |
| XHTML1.0<br>严格体现在小写标签、闭合、引号 | Strict    严格的，体现在一些标签不能使用，比如u<br>Transitional:普通的<br>Frameset:带有框架的页面 |

&emsp;&emsp;strict表示“严格的”，这种模式里面的要求更为严格。这种严格体现在,有一些标签不能使用。
比如，u标签，就是可以让一个本文加上下划线，但是这和HTML的本质有冲突，因为HTML只能负责语义，不能负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。增加下划线将通过使用css属性来解决。<br>

&emsp;&emsp;Transitional表示“普通的”，这种模式就是没有一些别的规范。<br>
&emsp;&emsp;Frameset表示“框架”，在框架的页面使用。<br>

&emsp;&emsp;sublime输入的`html:xt`<br>
&emsp;&emsp;x表示XHTML，t表示transitional<br><br>
&emsp;&emsp;HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了:<br>
```
    <!DOCTYPE html>
```

- - - 
### 字符集
```
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
```
&emsp;&emsp;字符集用meta标签定义，meta表示“元”。“元”配置，就是表示基本的配置项目。<br>
* 第一种：UTF-8<br>
```
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
```
* 第二种：gb2312<br>
```
    <meta http-equiv="Content-Type" content="text/html;charset=gb2312">
```
也可以写成gbk<br>
```
    <meta http-equiv="Content-Type" content="text/html;charset=gbk">
```

<br>
&emsp;&emsp;有两个字库UTF-8和gb2312。<br>
&emsp;&emsp;UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语……<br>
&emsp;&emsp;gb2312是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。<br>
<br>
&emsp;&emsp;字库规模：UTF-8（字全） > gb2312（只有汉字）<br>
<br>
&emsp;&emsp; ***我们用meta标签可以声明当前这个html文档的字库，但是一定要和保存的类型一样，否则乱码。（重点）***

&emsp;&emsp;当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 文件→ set File Encoding to → Chinese Simplified(GBK)<br>

&emsp;&emsp;注意，由于UTF-8里面保存了世界上所有人类语言，所以描述一个汉字需要的码更多。
UTF-8里面存储一个汉字**3**个字节。而gb2312中存储一个汉字**2**个字节。<br>

&emsp;&emsp;保存大小：UTF-8（更臃肿、加载更慢）> gb2312 （更小巧，加载更快）<br>
<br>
&emsp;&emsp;总结：<br>
&emsp;&emsp;UTF-8 字多，有各种国家的语言，但是保存尺寸大，文件臃肿；<br>
&emsp;&emsp;gb2312字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。<br>

- - - 
### 关键字和页面描述
&emsp;&emsp;`<meta name="Description" content="网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。" />`<br>
&emsp;&emsp;只要设置的Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做SEO，search engine optimization，搜索引擎优化。<br>
<br>
&emsp;&emsp;`<meta name="Keywords" content="网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信" />`<br>
&emsp;&emsp;这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。<br>

- - - 
### title标签
&emsp;&emsp;`<title>网页的标题</title>`<br>
&emsp;&emsp;title也是有助于SEO搜索引擎优化的.<br>

- - - 
### HTML的基本语法特性
&emsp;&emsp;HTML对换行不敏感，对tab不敏感<br>
&emsp;&emsp;HTML中所有的文字之间，如果有空格、换行、tab都将被折叠为一个空格显示。<br>
&emsp;&emsp;标签要严格封闭<br>
<br>
&emsp;&emsp;HTML标签是分等级的，HTML将所有的标签分为两种：容器级、文本级。<br>
&emsp;&emsp;顾名思义，容器级的标签，里面可以放置任何东西；文本级的标签里面，只能放置文字、图片、表单元素。<br>
&emsp;&emsp;锚点用name属性来设置，一个a标签如果name属性（或者id属性），那么就是页面的一个锚点。<br>

- - - 
### 定义列表
&emsp;&emsp;定义列表也是一个组标签，不过比较复杂，出现了三个标签：
 * dl表示definition list 定义列表
 * dt表示definition title    定义标题
 * dd表示definition description 定义表述词儿

- - - 
### 复选框
&emsp;&emsp;复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name）

- - - 
### 字符实体
&emsp;&emsp;`&lt;`<br>
&emsp;&emsp;就是 `<` 的字符实体，什么意思呢？就是用常用字符表示这些符号的方式。<br>
&emsp;&emsp;lt 就是英语less than 小于的意思；<br>

&emsp;&emsp;`&gt;`<br>
&emsp;&emsp;就是 `>` 的字符实体。<br>
&emsp;&emsp;gt就是greater than 大于的意思。<br>

&emsp;&emsp;`&copy;`<br>
&emsp;&emsp;就是 `©` 版权符号。<br>

&emsp;&emsp;`&nbsp;`<br>
&emsp;&emsp;nbsp就是英语non-breaking<br>&emsp;&emsp;spacing不打断空格的意思，就是空格。可以防止空白折叠现象。<br>

- - - 
### HTML废弃标签介绍
&emsp;&emsp;HTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。<br>
&emsp;&emsp;这些样式的标签，都已经被废弃。<br>

&emsp;&emsp;2004年之前的东西了：<br>
&emsp;&emsp;`<font size="9" color="red">Lemon Tea</font>`<br>

&emsp;&emsp;这些标签都是css钩子，而不是原意：
```
    <b>加粗</b>
    <u>下划线</u>
    <i>倾斜</i>
    <del>删除线</del>
    <em>强调</em>
    <strong>强调</strong>
```
&emsp;&emsp;这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。<br>

&emsp;&emsp;水平线：<br>
&emsp;&emsp;`<hr />`<br>

&emsp;&emsp;换行：<br>
&emsp;&emsp;`<br />`<br>
&emsp;&emsp;不另起一个段落，进行换行。<br>

&emsp;&emsp;网页中99.9999%需要换行的时候，是因为另起了一个段落，所以要用p，不要用`<br />`<br>
&emsp;&emsp;br是英语break打断的意思。<br>

&emsp;&emsp;标准的div+css页面，用的标签种类很少：<br>
&emsp;&emsp;`div  p  h1  span  a  img  ul  ol  dl  input`

- - -  

# CSS {#css}
&emsp;&emsp;css是`cascading style sheet`，`层叠式样式表`的简写。<br>
&emsp;&emsp;我们写css的地方是style标签，就是“样式”的意思，写在head里面。<br>
&emsp;&emsp;后面的课程你将知道，css也可以写在单独的文件里面，现在我们先写在style标签里面<br>
```
    <style type=”text/css”>

    </style>
```
&emsp;&emsp;type表示“类型”，text就是“纯文本”。css也是纯文本的。<br>
&emsp;&emsp;sublime这里如果想自动生成，那么要输入：<br>
&emsp;&emsp;`<st`然后按tab键。<br>
&emsp;&emsp;css对换行不敏感，对空格也不敏感。但是一定要有标准的语法。冒号，分号都不能省略。<br>

- - - 
### 常见属性
&emsp;&emsp;字符颜色：<br>
```
    color:red;
```
&emsp;&emsp;color属性的值，可以是英语单词，比如`red、blue、yellow`等等；也可以是`rgb`、`十六进制`。<br>
&emsp;&emsp;sublime中的快捷键是`c`，然后`tab`<br><br>

&emsp;&emsp;字号大小：<br>
```
    font-size:40px;
```
&emsp;&emsp;`font`就是“字体”，`size`就是“尺寸”。`px`是“像素”。<br>
&emsp;&emsp;单位必须加，不加不行。<br>
&emsp;&emsp;sublime中的快捷键是`fos`，然后`tab`<br>

&emsp;&emsp;背景颜色：<br>
```
    background-color: blue;
```
&emsp;&emsp;background就是“背景”。<br>
&emsp;&emsp;sublime中的快捷键是`bgc`，然后`tab`<br><br>

&emsp;&emsp;加粗：<br>
```
    font-weight: bold;
```

&emsp;&emsp;`font`是“字体” ，`weight`是“重量”的意思，bold粗。<br>
&emsp;&emsp;sublime中的快捷键是`fwb`，然后`tab`<br><br>

&emsp;&emsp;不加粗：<br>
```
    font-weight: normal;
```
&emsp;&emsp;normal就是正常的意思<br>
&emsp;&emsp;sublime中的快捷键是`fwn`，然后`tab`<br><br>


&emsp;&emsp;斜体：<br>
```
    font-style: italic;
```
&emsp;&emsp;`italic`就是“斜体”<br>
&emsp;&emsp;sublime中的快捷键是`fsi`，然后`tab`<br><br>

&emsp;&emsp;不斜体：<br>
```
    font-style: normal;
```
&emsp;&emsp;sublime中的快捷键是`fsn`，然后`tab`<br><br>

&emsp;&emsp;下划线：<br>
```
    text-decoration: underline;
```
&emsp;&emsp;`decoration`就是“装饰”的意思。<br>
&emsp;&emsp;sublime中的快捷键是`tdu`，然后`tab`<br><br>

&emsp;&emsp;没有下划线：<br>
```
    text-decoration:none;
```
&emsp;&emsp;sublime中的快捷键是`tdn`，然后`tab`<br>

- - - 
### 类选择器
&emsp;&emsp;1） 不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同造成这个标签的样式。<br>
&emsp;&emsp;2） 每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。

&emsp;&emsp;到底用id还是用class？<br>
&emsp;&emsp;答案：尽可能的用class，除非极特殊的情况可以用id。<br>
原因：id是js用的。也就是说，js要通过id属性得到标签，所以我们css层面尽量不用id，要不然js就很别扭。另一层面，我们会认为一个有id的元素，有动态效果。<br>

- - - 
### 后代选择器
```
    <style type="text/css">
        .div1 p{
            color:red;
        }
    </style>
```
&emsp;&emsp;空格就表示后代，.`div1 p` 就是.div1的后代所有的p。<br>
&emsp;&emsp;强调一下，选择的是后代，不一定是儿子。<br>

- - - 
### 交集选择器
```
    h3.special{
        color:red;
    }
```
&emsp;&emsp;选择的元素是同时满足两个条件：必须是h3标签，然后必须是special标签。<br>
&emsp;&emsp;交集选择器没有空格。<br>
&emsp;&emsp;所以有没有空格<br>
&emsp;&emsp;`div.red` 和 `div .red`不是一个意思。<br><br>
&emsp;&emsp;交集选择器可以连续交（一般不要这么写）<br>
```
    h3.special.zhongyao{
        color:red;
    }
```
&emsp;&emsp;交集选择器，我们一般都是以标签名开头，比如`div.haha`。<br>

- - - 
### 并集选择器（分组选择器）
```
    h3,li{
        color:red;
    }
```
&emsp;&emsp;用逗号就表示并集。<br>

- - - 
### 通配符*
&emsp;&emsp;`*` 就表示所有元素。<br>
```
    *{
        color:red;
    }
```
&emsp;&emsp;效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。<br>

- - - 
## 一些CSS3选择器
### 儿子选择器 `>`
&emsp;&emsp;**IE7开始兼容，IE6不兼容。**
```
    div>p{
        color:red;
    }
```
&emsp;&emsp;div的儿子p。和div的后代p的截然不同。<br>

- - -  
### 序选择器
&emsp;&emsp; **IE8开始兼容；IE6、7都不兼容**<br>
&emsp;&emsp;选择第1个li：
```
    <style type="text/css">
        ul li:first-child{
            color:red;
        }
    </style>
```

&emsp;&emsp;选择最后一个1i：
```
    ul li:last-child{
        color:blue;
    }
```
<br>&emsp;&emsp;由于浏览器的更新需要过程，所以现在如果公司还要求兼容IE6、7，那么就要自己写类名：
```
    <ul>
        <li class="first">项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li class="last">项目</li>
    </ul>
```
<br>&emsp;&emsp;用类选择器来选择第一个或者最后一个：
```
    ul li.first{
        color:red;
    }

    ul li.last{
        color:blue;
    }
```

- - - 
### 下一个兄弟选择器
&emsp;&emsp; **IE7开始兼容，IE6不兼容。** <br>
&emsp;&emsp;`+` 表示选择下一个兄弟
```
    <style type="text/css">
        h3+p{
            color:red;
        }
    </style>
```

<br>&emsp;&emsp;选择上的是h3元素后面紧挨着的第一个兄弟。
```   
    <h3>我是一个标题</h3>  
    <p>我是一个段落</p>   <-
    <p>我是一个段落</p>
    <p>我是一个段落</p>
    <h3>我是一个标题</h3>   
    <p>我是一个段落</p>     <-
    <p>我是一个段落</p>
    <p>我是一个段落</p>
    <h3>我是一个标题</h3>   
    <p>我是一个段落</p>   <-
    <p>我是一个段落</p>
    <p>我是一个段落</p>
    <h3>我是一个标题</h3>   
```

- - - 
### CSS的继承性和层叠性
#### 继承性
&emsp;&emsp;有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。<br>
&emsp;&emsp;哪些属性能继承？<br>
&emsp;&emsp;`color`、 `text-开头`的、`line-开头`的、`font-开头`的。<br>

&emsp;&emsp;这些`关于文字样式`的，都能够继承；<br>
&emsp;&emsp;所有`关于盒子的、定位`的、`布局`的属性都不能继承。<br>
&emsp;&emsp;继承性是从自己开始，直到最小的元素。<br><br>

- - - 
#### 层叠性
&emsp;&emsp;层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！<br><br>
&emsp;&emsp;当选择器，选择上了某个元素的时候，那么要这么统计权重：<br>
&emsp;&emsp;`id的数量，类的数量，标签的数量`<br>
&emsp;&emsp;**不进位，实际上能进位（奇淫知识点：255个标签，等于1个类名）但是没有实战意义！**<br>
&emsp;&emsp;如：`2,1,1`  比  `1，3，3`  大<br>

&emsp;&emsp;如果权重一样，那么以后出现的为准。<br>
&emsp;&emsp;如果大家都是0，那么有一个就近原则：`谁描述的近，听谁的。`<br><br>

- - - 
#### 权重问题深入
&emsp;&emsp;同一个标签，携带了多个类名，有冲突：
```
    <p class="spec1 spec2">我是什么颜色？</p>
    <p class="spec2 spec1">我是什么颜色？</p>
```

&emsp;&emsp;和在标签中的挂类名的书序无关，只和css的顺序有关：

```
    <style type="text/css">
        .spec2{
                color:blue;
            }
        .spec1{
                color:red;
            }
    </style>
```

&emsp;&emsp;红色的。因为css中red写在后面。

- - - 
#### !important标记
```
    <style type="text/css">
       p{
           color:red !important;
       }
       #para1{
           color:blue;
       }
       .spec{
           color:green;
      }
    </style>
```

&emsp;&emsp;important是英语里面的“重要的”的意思。我们可以通过语法：

```
    k:v !important;
```

&emsp;&emsp;来给一个属性提高权重。这个属性的权重就是`无穷大`。<br>
&emsp;&emsp;!important需要强调3点：<br>
&emsp;&emsp;1） !important提升的是一个`属性`，而不是一个选择器
```
    p{
       color:red !important;   → 只写了这一个!important，所以就字体颜色属性提升权重
       font-size: 100px ;      → 这条属性没有写!important，所以没有提升权重
    }
    #para1{
       color:blue;
       font-size: 50px;
    }
    .spec{
        color:green;
      font-size: 20px;
    }
```
&emsp;&emsp;所以，综合来看，字体颜色是red（听important的）；字号是50px（听id的）;<br><br>

&emsp;&emsp;2） !important`无法提升继承的权重`，该是0还是0<br>
&emsp;&emsp;比如HTML结构：
```
    <div>
        <p>哈哈哈哈哈哈哈哈</p>
    </div>
```

&emsp;&emsp;有CSS样式：
```
    div{
       color:red !important;
    }
    p{
       color:blue;
    }
```

&emsp;&emsp;由于div是通过继承性来影响文字颜色的，所以!important无法提升它的权重，权重依然是0。<br>
&emsp;&emsp;干不过p标签，因为p标签是实实在在选中了，所以字是蓝色的（以p为准）。<br><br>

&emsp;&emsp;3）!important`不影响就近原则`<br>
&emsp;&emsp;如果大家都是继承来的，按理说应该按照“就近原则”，那么important能否影响就近原则呢？<br>
&emsp;&emsp;答案是：不影响。远的，永远是远的。不能给远的写一个important，干掉近的。<br>

&emsp;&emsp;总结：<br>
![权重总结]({{ site.url }}/images/20170807/weight.jpg)

- - -
### 盒模型
#### 盒子中的区域
&emsp;&emsp;一个盒子中主要的属性就5个：`width`、`height`、`padding`、`border`、`margin`。<br>
&emsp;&emsp;`width`是“`宽度`”的意思，CSS中width指的是`内容的宽度`，而不是盒子的宽度。<br>
&emsp;&emsp;`height`是“`高度`”的意思，CSS中height指的是`内容的高度`，而不是盒子的高度<br>
&emsp;&emsp;`padding`是“`内边距`”的意思<br>
&emsp;&emsp;`border`是“`边框`”<br>
&emsp;&emsp;`margin`是“`外边距`”<br>
&emsp;&emsp;下面这两个盒子，真实占有宽高，完全相同，都是302*302：
```
    .box1{
       width: 100px;
       height: 100px;
       padding: 100px;
       border: 1px solid red;
    }

    .box2{
       width: 250px;
      height: 250px;
      padding: 25px;
      border:1px solid red;
    }
```
&emsp;&emsp;`真实占有宽度=  左border  +  左padding  +  width  +  右padding  +  右border`

- - -
### padding
&emsp;&emsp;padding就是`内边距`。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。<br>
&emsp;&emsp;也就是说，`background-color将填充所有boder以内的区域。`<br>
&emsp;&emsp;padding是4个方向的，所以我们能够分别描述4个方向的padding。<br><br>
&emsp;&emsp;方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。<br><br>
&emsp;&emsp;小属性：<br>
```
    padding-top: 30px;
    padding-right: 20px;
    padding-bottom: 40px;
    padding-left: 100px;
```
&emsp;&emsp;top上、right右、bottom下、left左。<br>
&emsp;&emsp;这种属性，就是复合属性。比如不写padding-left那么就是没有左内边距。<br>

&emsp;&emsp;快捷键就是`pdt`、`pdr`、`pdb`、`pdl` 然后按`tab`。<br>

&emsp;&emsp;综合属性：<br>
&emsp;&emsp;如果写了4个值：
```
    padding:30px 20px 40px 100px;
```
&emsp;&emsp;`上、右、下、左`<br>

&emsp;&emsp;如果只写3个值：
```
    padding: 20px 30px 40px;
```
&emsp;&emsp;上、右、下、??和右一样,即`缺少的就跟对面的一样`。<br>

&emsp;&emsp;也就是说，
```
    padding: 30px 40px;
```

&emsp;&emsp;等价于：
```
    padding-top: 30px;
    padding-bottom: 30px;
    padding-left: 40px;
    padding-right: 40px;
```

&emsp;&emsp;要懂得，`用小属性层叠大属性`：
```
    padding: 20px;
    padding-left: 30px;
```

&emsp;&emsp;下面的写法错误：<br>
```
    padding-left: 30px;
    padding: 20px;
```
&emsp;&emsp;`不能把小属性，写在大属性前面`。<br>

- - -
### border
&emsp;&emsp;就是`边框`。边框有三个要素：`粗细、线型、颜色`。<br>
&emsp;&emsp;颜色如果不写，默认是`黑色`。另外两个属性不写，则`显示不出`来边框。
```
    border: 1px dashed red;
```

&emsp;&emsp;border是一个大综合属性，
```
    border:1px solid red;
```
&emsp;&emsp;就是把4个边框，都设置为1px宽度、线型实线、red颜色。<br>

&emsp;&emsp;border属性能够被拆开，有两大种拆开的方式：<br>
&emsp;&emsp;1） 按3要素:`border-width`、`border-style`、`border-color`<br>
&emsp;&emsp;2） 按方向：`border-top`、`border-right`、`border-bottom`、`border-left`<br>

&emsp;&emsp;按3要素拆开：
```
    border-width:10px;    → 边框宽度
    border-style:solid;     → 线型
    border-color:red;      → 颜色。
```

&emsp;&emsp;等价于：
```
    border:10px solid red;
```

&emsp;&emsp;现在心里要明白，原来一个border是由三个小属性综合而成：<br>
&emsp;&emsp;`border-width`  `border-style`   `border-color`。<br>

&emsp;&emsp;如果某一个小要素后面是空格隔开的多个值，那么就是上右下左的顺序：
```
    border-width:10px 20px;
    border-style:solid dashed dotted;
    border-color:red green blue yellow;
```

&emsp;&emsp;按方向来拆
```
    border-top:10px solid red;
    border-right:10px solid red;
    border-bottom:10px solid red;
    border-left:10px solid red;
```

&emsp;&emsp;等价于
```
    border:10px solid red;
```

&emsp;&emsp;按方向还能再拆一层，就是把每个方向的，每个要素拆开，一共12条语句：
```
    border-top-width:10px;
    border-top-style:solid;
    border-top-color:red;
    border-right-width:10px;
    border-right-style:solid;
    border-right-color:red;
    border-bottom-width:10px;
    border-bottom-style:solid;
    border-bottom-color:red;
    border-left-width:10px;
    border-left-style:solid;
    border-left-color:red;
```

&emsp;&emsp;等价于
```
    border:10px solid red;
```

&emsp;&emsp;border可以没有，
```
    border:none;
```

&emsp;&emsp;某一条边没有：
```
    border-left: none;
```

&emsp;&emsp;也可以调整左边边框的宽度为0：
```
    border-left-width: 0;
```

- - - 
### 标准文档流
&emsp;&emsp;我们要看看标准流有哪些微观现象：<br>
&emsp;&emsp;1） 空白折叠现象：<br>
&emsp;&emsp;比如，如果我们想让img标签之间没有空隙，必须紧密连接：
```
<img src="images/0.jpg" /><img src="images/1.jpg" /><img src="images/2.jpg" />
```
&emsp;&emsp;2） 高矮不齐，底边对齐；<br>

&emsp;&emsp;3） 自动换行，一行写不满，换行写。<br>

- - -
#### 块级元素和行内元素
&emsp;&emsp;学习的初期，你就要知道，标准文档流等级森严。标签分为两种等级：<br>

&emsp;&emsp;1） `块级元素`<br>
&emsp;&emsp;● 霸占一行，不能与其他任何元素并列<br>
&emsp;&emsp;● 能接受宽、高<br>
&emsp;&emsp;● 如果不设置宽度，那么宽度将默认变为父亲的100%。<br>

&emsp;&emsp;2） `行内元素`<br>
&emsp;&emsp;● 与其他行内元素并排<br>
&emsp;&emsp;● 不能设置宽、高。默认的宽度，就是`文字的宽度`。<br>

&emsp;&emsp;在HTML中，我们已经将标签分过类，当时分为了：文本级、容器级。<br>
&emsp;&emsp;`文本级`：`p、span、a、b、i、u、em`<br>
&emsp;&emsp;`容器级`：`div、h系列、li、dt、dd`<br>

&emsp;&emsp;CSS的分类和上面的很像，就`p`不一样：<br>
&emsp;&emsp;`所有的文本级标签，都是行内元素`，除了p，`p是个文本级，但是是个块级元素`。<br>
&emsp;&emsp;`所有的容器级标签都是块级元素`。<br>

- - -
#### 块级元素和行内元素的相互转换
&emsp;&emsp;块级元素可以设置为行内元素<br>
&emsp;&emsp;行内元素可以设置为块级元素
```
    div{
        display: inline;
        background-color: pink;
        width: 500px;
        height: 500px;
    }
```

&emsp;&emsp;`display`是“`显示模式`”的意思，用来改变元素的行内、块级性质<br>
&emsp;&emsp;`inline`就是“`行内`”。<br>

&emsp;&emsp;一旦，给一个标签设置
```
    display: inline;
```
&emsp;&emsp;那么，这个标签将立即变为行内元素。此时它和一个span无异：<br>
&emsp;&emsp;● 此时这个div不能设置宽度、高度；<br>
&emsp;&emsp;● 此时这个div可以和别人并排了<br><br>

&emsp;&emsp;同样的道理，
```
    span{
        display: block;
        width: 200px;
        height: 200px;
        background-color: pink;
        }
```

&emsp;&emsp;“`block`”是“`块`”的意思<br>

&emsp;&emsp;让标签变为块级元素。此时这个标签，和一个div无异：<br>
&emsp;&emsp;● 此时这个span能够设置宽度、高度<br>
&emsp;&emsp;● 此时这个span必须霸占一行了，别人无法和他并排<br>
&emsp;&emsp;● 如果不设置宽度，将撑满父亲<br><br>

&emsp;&emsp;标准流里面限制非常多，标签的性质恶心。比如，我们现在就要并排、并且就要设置宽高。<br>
&emsp;&emsp;所以，移民！脱离标准流！<br>

&emsp;&emsp;css中一共有三种手段，使一个元素`脱离标准文档流`：<br>
&emsp;&emsp;1） `浮动`<br>
&emsp;&emsp;2） `绝对定位`<br>
&emsp;&emsp;3） `固定定位`<br>

- - -
### 浮动
&emsp;&emsp;浮动是css里面布局用得最多的属性。
```
    .box1{
        float: left;
        width: 300px;
        height: 400px;
        background-color: yellowgreen;
    }
    .box2{
        float: left;
        width: 400px;
        height: 400px;
        background-color: skyblue;
    }
```
&emsp;&emsp;两个元素并排了，并且两个元素都能够设置宽度、高度了（这在刚才的标准流中，不能实现）。<br>
&emsp;&emsp;浮动想学好，一定要知道三个性质。

#### **浮动的元素脱标**
&emsp;&emsp;证明1：
![元素脱标]({{ site.url }}/images/20170807/float.png)

&emsp;&emsp;证明2：<br>
&emsp;&emsp;一个span标签不需要转成块级元素，就能够设置宽度、高度了。所以能够证明一件事儿，就是所有标签已经不区分行内、块了。也就是说，一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。
```
    span{
        float: left;
        width: 200px;
        height: 200px;
        background-color: orange;
    }
```

#### **浮动的元素互相贴靠**
&emsp;&emsp;如果有足够空间，那么就会靠着2号标签。如果没有足够的空间，那么会靠着1号标签。<br>
&emsp;&emsp;如果没有足够的空间靠着1号标签，自己去贴左墙。
![元素贴靠]({{ site.url }}/images/20170807/float1.png)

&emsp;&emsp;右浮动：`float:right; `
![元素贴靠]({{ site.url }}/images/20170807/float2.png)


#### 浮动的元素有“字围”效果
```
    <div>
       <img src="images/1.jpg" alt="" />
    </div>
    <p>123文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字
    </p>
```
&emsp;&emsp;让div浮动，p不浮动：<br>
 
&emsp;&emsp;div挡住了p，但是p中的文字不会被挡住，形成“字围”效果。<br>

&emsp;&emsp;关于浮动我们要强调一点，浮动这个东西，我们在初期一定要遵循一个原则：<br>
&emsp;&emsp;`永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。`<br>

- - -
#### 浮动性质的总结
&emsp;&emsp;浮动的性质：`脱标、贴边、字围、收缩`。<br>
&emsp;&emsp;收缩：一个浮动的元素，如果没有设置`width`，那么将自动收缩为`文字的宽度`（这点非常像行内元素）。<br>
&emsp;&emsp;整个网页，就是通过`浮动`，来实现`并排`的。

- - -
### 浮动的清除
#### 清除浮动方法1：给浮动的元素的祖先元素加高度。
&emsp;&emsp;如果一个元素要浮动，那么它的`祖先元素一定要有高度`。有高度的盒子，才能关住浮动。<br>
&emsp;&emsp;只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。

- - - 
#### 清除浮动方法2：clear:both;
&emsp;&emsp;网页制作中，高度height很少出现。为什么？因为能被内容撑高！那也就是说，刚才我们讲解的方法1，工作中用的很少。
```
    clear:both;
```
&emsp;&emsp;clear就是清除，both指的是左浮动、右浮动都要清除。意思就是：清除别人对我的影响。<br>
&emsp;&emsp;这种方法有一个非常大的、致命的问题，`margin失效`了。

- - - 
#### 清除浮动方法3：隔墙法
```
    <div class="box1">
        <ul>
            <li>HTML</li>
            <li>CSS</li>
            <li>JS</li>
            <li>HTML5</li>
            <li>设计模式</li>
        </ul>
    </div>
      
    <div class="cl h16"></div>
  
    <div class="box2">
        <ul>
            <li>学习方法</li>
            <li>英语水平</li>
            <li>面试技巧</li>
        </ul>
    </div>
```

```
    .cl{
        clear: both;
    }
    .h16{
        height: 16px;
    }
```


&emsp;&emsp;近些年，有演化出了“内墙法”：
```
    <div class="box1">
        <ul>
            <li>HTML</li>
            <li>CSS</li>
            <li>JS</li>
            <li>HTML5</li>
            <li>设计模式</li>
        </ul>

        <div class="cl h16"></div>
    </div>
      
    <div class="box2">
        <ul>
            <li>学习方法</li>
            <li>英语水平</li>
            <li>面试技巧</li>
        </ul>
    </div>
```

- - - 
#### 清除浮动方法4：overflow:hidden;
&emsp;&emsp;overflow就是“溢出”的意思， hidden就是“隐藏”的意思。
```
   overflow:hidden; 
```
&emsp;&emsp;&emsp;&emsp;表示“溢出隐藏”。所有溢出边框的内容，都要隐藏掉。<br>
&emsp;&emsp;本意就是清除溢出到盒子外面的文字。但是，前端开发工程师又发现了，它能做偏方。<br>

&emsp;&emsp;一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上overflow:hidden;那么，父亲就能被儿子撑出高了。这是一个偏方。

- - - 
#### 清除浮动总结与案例
&emsp;&emsp;总结一下：<br>
&emsp;&emsp;1） 加高法：<br>
&emsp;&emsp;浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。但是，工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。
```
    <div>   → 设置height
       <p></p>
       <p></p>
       <p></p>   </div>
   
    <div>   → 设置height
       <p></p>
       <p></p>
       <p></p>
    </div>
```

&emsp;&emsp;2) clear:both;法<br>
&emsp;&emsp;最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。
``` 
    <div>
        <p></p>
        <p></p>
        <p></p>   </div>      <div>   → clear:both;
        <p></p>
        <p></p>
        <p></p>
   </div>
```
&emsp;&emsp;浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。<br>

&emsp;&emsp;3）隔墙法：<br>
&emsp;&emsp;在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。<br>
&emsp;&emsp;墙用自己的身体当做了间隙。
```
   <div>
        <p></p>
        <p></p>
        <p></p>
    </div>
   
    <div class="cl h10"></div>
   
    <div>
        <p></p>
        <p></p>
        <p></p>
    </div>
```
&emsp;&emsp;我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动的根据自己的儿子，撑出高度，我们就要想一些“小伎俩”，“奇淫技巧”。<br>

&emsp;&emsp;内墙法：
```
    <div>
        <p></p>
        <p></p>
        <p></p>
        <div class="cl h10"></div>
    </div>
    
    <div>
        <p></p>
        <p></p>
      <p></p>
    </div>
```
&emsp;&emsp;内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。<br>

&emsp;&emsp;4）overflow:hidden;<br>
&emsp;&emsp;这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。<br>
&emsp;&emsp;我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的小偏方。<br>
&emsp;&emsp;并且,`overflow:hidden;能够让margin生效`。

- - - 
#### 浏览器兼容问题
&emsp;&emsp;第一，IE6，不支持`小于12px的盒子`，任何小于12px的盒子，在IE6中看都大<br>
&emsp;&emsp;解决办法很简单，就是将盒子的字号，设置小（小于盒子的高），比如0px。
```
   height: 4px;
   _font-size: 0px;
```
&emsp;&emsp;我们现在介绍一下浏览器hack。hack就是“黑客”，就是使用浏览器提供的后门，针对某一种浏览器做兼容。<br><br>
&emsp;&emsp;IE6留了一个后门，就是只要给css属性之前，加上下划线，这个属性就是IE6认识的专有属性。<br>
&emsp;&emsp;比如：
```
   _background-color: green;
```

&emsp;&emsp;解决微型盒子，正确写法：
```
   height: 10px;
   _font-size:0;
```

&emsp;&emsp;第二，IE6不支持用overflow:hidden;来清除浮动的<br>
&emsp;&emsp;解决办法，以毒攻毒。追加一条
```
   _zoom:1;
```

&emsp;&emsp;完整写法：
```   
    overflow: hidden;
      _zoom:1;
```

&emsp;&emsp;实际上，`_zoom:1;`能够触发浏览器`hasLayout`机制。这个机制，不要深究了，因为`就IE6有`。我们只需要让IE6好用，具体的实现机制，有兴趣的同学，自行百度。<br>

&emsp;&emsp;强调一点，`overflow:hidden;`的本意，就是溢出盒子的border的东西隐藏，这个功能是IE6兼容的。不兼容的是`overflow:hidden;清除浮动`的时候。<br>

&emsp;&emsp;我们刚才学习了两个IE6的兼容问题，这两个IE6的兼容问题，都是通过多写一条hack来解决的。<br>
&emsp;&emsp;这个我们称为`伴生属性`。
```
   height:6px;
   _font-size:0;

   overflow:hidden;
   _zoom:1;
```

- - - 
### margin
#### margin的塌陷现象
&emsp;&emsp;`标准文档流中`，`竖直方向`的`margin不叠加`，以`较大`的为准<br>

&emsp;&emsp;如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的：

- - - 
#### 盒子居中 margin:0 auto;
&emsp;&emsp;margin的值可以为`auto，表示自动`。当left、right两个方向，都是auto的时候，盒子`居中`了：
``` 
    margin-left: auto;
    margin-right: auto;
```
简写为
``` 
   margin:0 auto;
```

&emsp;&emsp;注意：<br>
&emsp;&emsp;1） 使用`margin:0 auto;` 的盒子，`必须有width，有明确的width`<br><br>
&emsp;&emsp;2） 只有`标准流`的盒子，才能使用`margin:0 auto; `居中。<br>
&emsp;&emsp;也就是说，`当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto;`<br>
&emsp;&emsp;3） `margin:0 auto;是在居中盒子`，不是居中文本。<br>
&emsp;&emsp;文本的居中，要使用
```
    text-align:center;

    margin:0 auto;   → 让这个div自己在大容器中居中。
    text-align: center;  → 让这个div内部的文本居中。
```

&emsp;&emsp;普及一下知识，text-align还有
```
    text-align:left;     没啥用，因为默认居左
    text-align:right;    文本居右
```

- - -
#### `善于使用父亲的padding，而不是儿子的margin`
&emsp;&emsp;如果父亲没有border，那么儿子的margin实际上踹的是“`流`”，踹的是这“行”。所以，父亲整体也掉下来了<br>
&emsp;&emsp;这个p有一个`margin-top`踹父亲，试图将自己下移
```
    <div>
        <p></p>
    </div>
```
&emsp;&emsp;结果：<br>
&emsp;&emsp;`margin`这个属性，本质上描述的是`兄弟和兄弟之间的距离`；<br>最好不要用这个marign表达父子之间的距离。<br>
&emsp;&emsp;所以，我们一定要善于使用`父亲的padding`，而不是`儿子的margin`。

- - -
#### 关于margin的IE6兼容问题
&emsp;&emsp;当出现连续浮动的元素，携带和浮动方向相同的margin时，队首的元素，会双倍marign。<br><br>
&emsp;&emsp;解决方案：<br>
&emsp;&emsp;1）使浮动的方向和margin的方向，相反。<br>
&emsp;&emsp;所以，你就会发现，我们特别喜欢，浮动的方向和margin的方向相反。并且，前端开发工程师，把这个当做习惯了。
```
    float: left;
    margin-right: 40px;
```
&emsp;&emsp;2）使用hack（没必要，别惯着这个IE6）
&emsp;&emsp;单独给队首的元素，写一个一半的margin
```
   <li class="no1"></li>

   ul li.no1{
       _margin-left:20px;3 
   }
```
 
&emsp;&emsp;IE6的3px bug<br><br>
&emsp;&emsp;解决办法：<br>
&emsp;&emsp;不用管，因为根本就不允许用儿子踹父亲。所以，如果你出现了3px bug，说明你的代码不标准。

- - -
### Fireworks和精确盒子还原
```
   line-height
```
&emsp;&emsp;属性。顾名思义，就是行的高度。<br>

&emsp;&emsp;首行空两个汉字的格，单位比较奇怪，叫做`em`，`em就是汉字的一个宽度`。
```
   text-indent:2em;
```
&emsp;&emsp;`indent`就是“`缩进`”的意思。<br>



















