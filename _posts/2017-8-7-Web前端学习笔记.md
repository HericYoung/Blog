---
layout: post
title: Web前端学习笔记
description: \[o_o\]只针对个人觉得需要记录的知识点进行记录，不适合用作前端的系统学习
category: Programming
tags: []
image: 
    feature: 
---

1.[Html](#html)<br>
2.[CSS](#css)<br>
3.[JavaScript](#javascript)<br>
4.[jQuery](#jquery)<br>
5.[Html5](#html5)<br>

## Html {#html}
&emsp;&emsp;HTML是英语HyperText Markup Language的缩写，超文本标记语言。<br>
&emsp;&emsp;html本质上和txt没有任何区别，他们都是纯文本文件。<br>

&emsp;&emsp;现在的业界的标准，网页技术严格的三层分离：html就是负责描述页面的语义；css负责描述页面的样式；js负责描述页面的动态效果的。<br>
&emsp;&emsp;HTML是负责描述文档语义的语言,除了语义，其他什么都没有。<br>

```
    <html>
        <head>
            
        </head>
        <body>
            
        </body>
    </html>
```
&emsp;&emsp;网页的最外层的标签对儿是`<html></html>`标签对儿，里面有两部分，分别是head和body。<br>
&emsp;&emsp;head标签中，描述网页的配置；body中的内容，才是用户可以看见的内容。<br><br><br>
```
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
        <head>
          <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
          <title>标题</title>
        </head>
        <body>
          
        </body>
    </html>
```
&emsp;&emsp;第1行，就是网页的声明头，术语叫做DocType Defintion，文档类型定义，简称DTD。这行语句非常的复杂，里面暗含了一个网址。W3C就是出web规范的组织机构。html、css、js的规范都是W3C定义发布的。world wide web coalition , 国际万维网联盟。网页声明头可以告诉浏览器，这是一个什么标准的页面。<br>
&emsp;&emsp;第2行，是最大的html标签，所有的网页内容，都要包裹在这个标签对儿里面。
我们发现，html标签中，有两个属性：<br>
&emsp;&emsp;`xmlns="http://www.w3.org/1999/xhtml" `,命名空间，就是一个规范；<br>
&emsp;&emsp;&emsp;&emsp;`xml:lang="en" `,语言是英语<br>
&emsp;&emsp;第3行，就是head标签，就是配置。<br>
&emsp;&emsp;第4行，`<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> `字符集的配置<br>
&emsp;&emsp;第5行，`<title>标题</title>`，网页的标题，可以显示在浏览器的标签栏中。<br>
&emsp;&emsp;第7行，body标签就是网页的内容，用户能够看见。<br>

- - - 
### 文档声明头
```
    <!DOCTYPE ……
```
&emsp;&emsp;Html文件开头的语句。<br>
&emsp;&emsp;这一行，就是文档声明头，DocType Declaration。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。<br>
&emsp;&emsp;HTML4.01版本是IE6开始兼容的。HTML5是IE9开开始兼容的。但是IE6、7、8这些浏览器还不能过早的淘汰，所以这几年网页还是应该用HTML4.01来制作。后面将知道手机、移动端的网页，就可以使用HTML5了。<br>

&emsp;&emsp;HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下面）：<br>
&emsp;&emsp;HTML4.01里面规定了普通、XHTML两大种规范。<br>
总结一下，一共有6种DTD，说白了，HTML第一行语句一共有6种：<br>

| 大规范 | 小规范 |
|-|-|
| HTML4.01 | Strict:严格的，体现在一些标签不能使用，比如u<br>Transitional:普通的<br>Frameset:带有框架的页面 |
| XHTML1.0<br>严格体现在小写标签、闭合、引号 | Strict    严格的，体现在一些标签不能使用，比如u<br>Transitional:普通的<br>Frameset:带有框架的页面 |

&emsp;&emsp;strict表示“严格的”，这种模式里面的要求更为严格。这种严格体现在,有一些标签不能使用。
比如，u标签，就是可以让一个本文加上下划线，但是这和HTML的本质有冲突，因为HTML只能负责语义，不能负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。增加下划线将通过使用css属性来解决。<br>

&emsp;&emsp;Transitional表示“普通的”，这种模式就是没有一些别的规范。<br>
&emsp;&emsp;Frameset表示“框架”，在框架的页面使用。<br>

&emsp;&emsp;sublime输入的`html:xt`<br>
&emsp;&emsp;x表示XHTML，t表示transitional<br><br>
&emsp;&emsp;HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了:<br>
```
    <!DOCTYPE html>
```

- - - 
### 字符集
```
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
```
&emsp;&emsp;字符集用meta标签定义，meta表示“元”。“元”配置，就是表示基本的配置项目。<br/>
- 第一种：UTF-8<br/>

```
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
```

- 第二种：gb2312<br>

```
    <meta http-equiv="Content-Type" content="text/html;charset=gb2312">
```

也可以写成gbk<br>
```
    <meta http-equiv="Content-Type" content="text/html;charset=gbk">
```

&emsp;&emsp;有两个字库UTF-8和gb2312。<br>
&emsp;&emsp;`UTF-8`是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语……<br>
&emsp;&emsp;`gb2312`是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。<br>
<br>
&emsp;&emsp;字库规模：UTF-8（字全） > gb2312（只有汉字）<br>
<br>
&emsp;&emsp; ***我们用meta标签可以声明当前这个html文档的字库，但是一定要和保存的类型一样，否则乱码。（重点）***

&emsp;&emsp;当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 文件→ set File Encoding to → Chinese Simplified(GBK)<br>

&emsp;&emsp;注意，由于UTF-8里面保存了世界上所有人类语言，所以描述一个汉字需要的码更多。
UTF-8里面存储一个汉字**3**个字节。而gb2312中存储一个汉字**2**个字节。<br>

&emsp;&emsp;保存大小：UTF-8（更臃肿、加载更慢）> gb2312 （更小巧，加载更快）<br>
<br>
&emsp;&emsp;总结：<br>
&emsp;&emsp;UTF-8 字多，有各种国家的语言，但是保存尺寸大，文件臃肿；<br>
&emsp;&emsp;gb2312字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。<br>

- - - 
### 关键字和页面描述
```
    <meta name="Description" content="网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。" />
```
&emsp;&emsp;只要设置的Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做SEO，search engine optimization，搜索引擎优化。<br>
<br>
```
    <meta name="Keywords" content="网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信" />
```
&emsp;&emsp;这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。<br>

- - - 
### title标签
```
    <title>网页的标题</title>
```
&emsp;&emsp;title也是有助于SEO搜索引擎优化的.<br>

- - - 
### HTML的基本语法特性
&emsp;&emsp;HTML对换行不敏感，对tab不敏感<br>
&emsp;&emsp;HTML中所有的文字之间，如果有空格、换行、tab都将`被折叠为一个空格`显示。<br>
&emsp;&emsp;标签要`严格封闭`<br>
<br>
&emsp;&emsp;HTML标签是分等级的，HTML将所有的标签分为两种：容器级、文本级。<br>
&emsp;&emsp;顾名思义，容器级的标签，里面可以放置任何东西；文本级的标签里面，只能放置文字、图片、表单元素。<br>
&emsp;&emsp;锚点用`属性`来设置，一个a标签如果有`name属性（或者id属性）`，那么就是页面的一个锚点。<br>

- - - 
### 定义列表
&emsp;&emsp;定义列表也是一个组标签，不过比较复杂，出现了三个标签：
- `dl`表示definition list 定义列表
- `dt`表示definition title    定义标题
- `dd`表示definition description 定义表述词儿

- - - 
### 复选框
&emsp;&emsp;复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name）

- - - 
### 字符实体
&emsp;&emsp;`&lt;`<br>
&emsp;&emsp;就是 `<` 的字符实体，什么意思呢？就是用常用字符表示这些符号的方式。<br>
&emsp;&emsp;lt 就是英语less than 小于的意思；<br>

&emsp;&emsp;`&gt;`<br>
&emsp;&emsp;就是 `>` 的字符实体。<br>
&emsp;&emsp;gt就是greater than 大于的意思。<br>

&emsp;&emsp;`&copy;`<br>
&emsp;&emsp;就是 `©` 版权符号。<br>

&emsp;&emsp;`&nbsp;`<br>
&emsp;&emsp;nbsp就是英语non-breaking<br>&emsp;&emsp;spacing不打断空格的意思，就是空格。可以防止空白折叠现象。<br>

- - - 
### HTML废弃标签介绍
&emsp;&emsp;HTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。<br>
&emsp;&emsp;这些样式的标签，都已经被废弃。<br>

&emsp;&emsp;2004年之前的东西了：<br>
&emsp;&emsp;`<font size="9" color="red">Lemon Tea</font>`<br>

&emsp;&emsp;这些标签都是css钩子，而不是原意：
```
    <b>加粗</b>
    <u>下划线</u>
    <i>倾斜</i>
    <del>删除线</del>
    <em>强调</em>
    <strong>强调</strong>
```
&emsp;&emsp;这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。<br>

&emsp;&emsp;水平线：<br>
&emsp;&emsp;`<hr />`<br>

&emsp;&emsp;换行：<br>
&emsp;&emsp;`<br />`<br>
&emsp;&emsp;不另起一个段落，进行换行。<br>

&emsp;&emsp;网页中99.9999%需要换行的时候，是因为另起了一个段落，所以要用p，不要用`<br />`<br>
&emsp;&emsp;br是英语break打断的意思。<br>

&emsp;&emsp;标准的div+css页面，用的标签种类很少：<br>
&emsp;&emsp;`div  p  h1  span  a  img  ul  ol  dl  input`

- - -  

## CSS {#css}
&emsp;&emsp;css是`cascading style sheet`，`层叠式样式表`的简写。<br>
&emsp;&emsp;我们写css的地方是style标签，就是“样式”的意思，写在head里面。<br>
&emsp;&emsp;后面的课程你将知道，css也可以写在单独的文件里面，现在我们先写在style标签里面<br>
```
    <style type=”text/css”>

    </style>
```
&emsp;&emsp;type表示“类型”，text就是“纯文本”。css也是纯文本的。<br>
&emsp;&emsp;sublime这里如果想自动生成，那么要输入：<br>
&emsp;&emsp;`<st`然后按tab键。<br>
&emsp;&emsp;css对换行不敏感，对空格也不敏感。但是一定要有标准的语法。冒号，分号都不能省略。<br>

- - - 
### 常见属性
&emsp;&emsp;字符颜色：<br>
```
    color:red;
```
&emsp;&emsp;color属性的值，可以是英语单词，比如`red、blue、yellow`等等；也可以是`rgb`、`十六进制`。<br>
&emsp;&emsp;sublime中的快捷键是`c`，然后`tab`<br><br>

&emsp;&emsp;字号大小：<br>
```
    font-size:40px;
```
&emsp;&emsp;`font`就是“字体”，`size`就是“尺寸”。`px`是“像素”。<br>
&emsp;&emsp;单位必须加，不加不行。<br>
&emsp;&emsp;sublime中的快捷键是`fos`，然后`tab`<br>

&emsp;&emsp;背景颜色：<br>
```
    background-color: blue;
```
&emsp;&emsp;background就是“背景”。<br>
&emsp;&emsp;sublime中的快捷键是`bgc`，然后`tab`<br><br>

&emsp;&emsp;加粗：<br>
```
    font-weight: bold;
```

&emsp;&emsp;`font`是“字体” ，`weight`是“重量”的意思，bold粗。<br>
&emsp;&emsp;sublime中的快捷键是`fwb`，然后`tab`<br><br>

&emsp;&emsp;不加粗：<br>
```
    font-weight: normal;
```
&emsp;&emsp;normal就是正常的意思<br>
&emsp;&emsp;sublime中的快捷键是`fwn`，然后`tab`<br><br>


&emsp;&emsp;斜体：<br>
```
    font-style: italic;
```
&emsp;&emsp;`italic`就是“斜体”<br>
&emsp;&emsp;sublime中的快捷键是`fsi`，然后`tab`<br><br>

&emsp;&emsp;不斜体：<br>
```
    font-style: normal;
```
&emsp;&emsp;sublime中的快捷键是`fsn`，然后`tab`<br><br>

&emsp;&emsp;下划线：<br>
```
    text-decoration: underline;
```
&emsp;&emsp;`decoration`就是“装饰”的意思。<br>
&emsp;&emsp;sublime中的快捷键是`tdu`，然后`tab`<br><br>

&emsp;&emsp;没有下划线：<br>
```
    text-decoration:none;
```
&emsp;&emsp;sublime中的快捷键是`tdn`，然后`tab`<br>

- - - 
### 类选择器
&emsp;&emsp;1） 不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同造成这个标签的样式。<br>
&emsp;&emsp;2） 每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。

&emsp;&emsp;到底用id还是用class？<br>
&emsp;&emsp;答案：尽可能的用class，除非极特殊的情况可以用id。<br>
原因：id是js用的。也就是说，js要通过id属性得到标签，所以我们css层面尽量不用id，要不然js就很别扭。另一层面，我们会认为一个有id的元素，有动态效果。<br>

- - - 
### 后代选择器
```
    <style type="text/css">
        .div1 p{
            color:red;
        }
    </style>
```
&emsp;&emsp;空格就表示后代，.`div1 p` 就是.div1的后代所有的p。<br>
&emsp;&emsp;强调一下，选择的是后代，不一定是儿子。<br>

- - - 
### 交集选择器
```
    h3.special{
        color:red;
    }
```
&emsp;&emsp;选择的元素是同时满足两个条件：必须是h3标签，然后必须是special标签。<br>
&emsp;&emsp;交集选择器没有空格。<br>
&emsp;&emsp;所以有没有空格<br>
&emsp;&emsp;`div.red` 和 `div .red`不是一个意思。<br><br>
&emsp;&emsp;交集选择器可以连续交（一般不要这么写）<br>
```
    h3.special.zhongyao{
        color:red;
    }
```
&emsp;&emsp;交集选择器，我们一般都是以标签名开头，比如`div.haha`。<br>

- - - 
### 并集选择器（分组选择器）
```
    h3,li{
        color:red;
    }
```
&emsp;&emsp;用逗号就表示并集。<br>

- - - 
### 通配符*
&emsp;&emsp;`*` 就表示所有元素。<br>
```
    *{
        color:red;
    }
```
&emsp;&emsp;效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。<br>

- - - 
### 一些CSS3选择器
#### 儿子选择器 `>`
&emsp;&emsp;**IE7开始兼容，IE6不兼容。**
```
    div>p{
        color:red;
    }
```
&emsp;&emsp;div的儿子p。和div的后代p的截然不同。<br>

- - -  
#### 序选择器
&emsp;&emsp; **IE8开始兼容；IE6、7都不兼容**<br>
&emsp;&emsp;选择第1个li：
```
    <style type="text/css">
        ul li:first-child{
            color:red;
        }
    </style>
```

&emsp;&emsp;选择最后一个1i：
```
    ul li:last-child{
        color:blue;
    }
```
<br>&emsp;&emsp;由于浏览器的更新需要过程，所以现在如果公司还要求兼容IE6、7，那么就要自己写类名：
```
    <ul>
        <li class="first">项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li>项目</li>
        <li class="last">项目</li>
    </ul>
```
<br>&emsp;&emsp;用类选择器来选择第一个或者最后一个：
```
    ul li.first{
        color:red;
    }

    ul li.last{
        color:blue;
    }
```

- - - 
#### 下一个兄弟选择器
&emsp;&emsp; **IE7开始兼容，IE6不兼容。** <br>
&emsp;&emsp;`+` 表示选择下一个兄弟
```
    <style type="text/css">
        h3+p{
            color:red;
        }
    </style>
```

<br>&emsp;&emsp;选择上的是h3元素后面紧挨着的第一个兄弟。
```   
    <h3>我是一个标题</h3>  
    <p>我是一个段落</p>   <-
    <p>我是一个段落</p>
    <p>我是一个段落</p>
    <h3>我是一个标题</h3>   
    <p>我是一个段落</p>     <-
    <p>我是一个段落</p>
    <p>我是一个段落</p>
    <h3>我是一个标题</h3>   
    <p>我是一个段落</p>   <-
    <p>我是一个段落</p>
    <p>我是一个段落</p>
    <h3>我是一个标题</h3>   
```

- - - 
### CSS的继承性和层叠性
#### 继承性
&emsp;&emsp;有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。<br>
&emsp;&emsp;哪些属性能继承？<br>
&emsp;&emsp;`color`、 `text-开头`的、`line-开头`的、`font-开头`的。<br>

&emsp;&emsp;这些`关于文字样式`的，都能够继承；<br>
&emsp;&emsp;所有`关于盒子的、定位`的、`布局`的属性都不能继承。<br>
&emsp;&emsp;继承性是从自己开始，直到最小的元素。<br><br>

- - - 
#### 层叠性
&emsp;&emsp;层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！<br><br>
&emsp;&emsp;当选择器，选择上了某个元素的时候，那么要这么统计权重：<br>
&emsp;&emsp;`id的数量，类的数量，标签的数量`<br>
&emsp;&emsp;**不进位，实际上能进位（奇淫知识点：255个标签，等于1个类名）但是没有实战意义！**<br>
&emsp;&emsp;如：`2,1,1`  比  `1，3，3`  大<br>

&emsp;&emsp;如果权重一样，那么以后出现的为准。<br>
&emsp;&emsp;如果大家都是0，那么有一个就近原则：`谁描述的近，听谁的。`<br><br>

- - - 
#### 权重问题深入
&emsp;&emsp;同一个标签，携带了多个类名，有冲突：
```
    <p class="spec1 spec2">我是什么颜色？</p>
    <p class="spec2 spec1">我是什么颜色？</p>
```

&emsp;&emsp;和在标签中的挂类名的书序无关，只和css的顺序有关：

```
    <style type="text/css">
        .spec2{
                color:blue;
            }
        .spec1{
                color:red;
            }
    </style>
```

&emsp;&emsp;红色的。因为css中red写在后面。

- - - 
#### !important标记
```
    <style type="text/css">
       p{
           color:red !important;
       }
       #para1{
           color:blue;
       }
       .spec{
           color:green;
      }
    </style>
```

&emsp;&emsp;important是英语里面的“重要的”的意思。我们可以通过语法：

```
    k:v !important;
```

&emsp;&emsp;来给一个属性提高权重。这个属性的权重就是`无穷大`。<br>
&emsp;&emsp;!important需要强调3点：<br>
&emsp;&emsp;1） !important提升的是一个`属性`，而不是一个选择器
```
    p{
       color:red !important;   → 只写了这一个!important，所以就字体颜色属性提升权重
       font-size: 100px ;      → 这条属性没有写!important，所以没有提升权重
    }
    #para1{
       color:blue;
       font-size: 50px;
    }
    .spec{
        color:green;
      font-size: 20px;
    }
```
&emsp;&emsp;所以，综合来看，字体颜色是red（听important的）；字号是50px（听id的）;<br><br>

&emsp;&emsp;2） !important`无法提升继承的权重`，该是0还是0<br>
&emsp;&emsp;比如HTML结构：
```
    <div>
        <p>哈哈哈哈哈哈哈哈</p>
    </div>
```

&emsp;&emsp;有CSS样式：
```
    div{
       color:red !important;
    }
    p{
       color:blue;
    }
```

&emsp;&emsp;由于div是通过继承性来影响文字颜色的，所以!important无法提升它的权重，权重依然是0。<br>
&emsp;&emsp;干不过p标签，因为p标签是实实在在选中了，所以字是蓝色的（以p为准）。<br><br>

&emsp;&emsp;3）!important`不影响就近原则`<br>
&emsp;&emsp;如果大家都是继承来的，按理说应该按照“就近原则”，那么important能否影响就近原则呢？<br>
&emsp;&emsp;答案是：不影响。远的，永远是远的。不能给远的写一个important，干掉近的。<br>

&emsp;&emsp;总结：<br>
![权重总结]({{ site.url }}/images/20170807/weight.jpg)

- - -
### 盒模型
#### 盒子中的区域
&emsp;&emsp;一个盒子中主要的属性就5个：`width`、`height`、`padding`、`border`、`margin`。<br>
&emsp;&emsp;`width`是“`宽度`”的意思，CSS中width指的是`内容的宽度`，而不是盒子的宽度。<br>
&emsp;&emsp;`height`是“`高度`”的意思，CSS中height指的是`内容的高度`，而不是盒子的高度<br>
&emsp;&emsp;`padding`是“`内边距`”的意思<br>
&emsp;&emsp;`border`是“`边框`”<br>
&emsp;&emsp;`margin`是“`外边距`”<br>
&emsp;&emsp;下面这两个盒子，真实占有宽高，完全相同，都是302*302：
```
    .box1{
       width: 100px;
       height: 100px;
       padding: 100px;
       border: 1px solid red;
    }

    .box2{
       width: 250px;
      height: 250px;
      padding: 25px;
      border:1px solid red;
    }
```
&emsp;&emsp;`真实占有宽度=  左border  +  左padding  +  width  +  右padding  +  右border`

- - -
#### padding
&emsp;&emsp;padding就是`内边距`。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。<br>
&emsp;&emsp;也就是说，`background-color将填充所有boder以内的区域。`<br>
&emsp;&emsp;padding是4个方向的，所以我们能够分别描述4个方向的padding。<br><br>
&emsp;&emsp;方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。<br><br>
&emsp;&emsp;小属性：<br>
```
    padding-top: 30px;
    padding-right: 20px;
    padding-bottom: 40px;
    padding-left: 100px;
```
&emsp;&emsp;top上、right右、bottom下、left左。<br>
&emsp;&emsp;这种属性，就是复合属性。比如不写padding-left那么就是没有左内边距。<br>

&emsp;&emsp;快捷键就是`pdt`、`pdr`、`pdb`、`pdl` 然后按`tab`。<br>

&emsp;&emsp;综合属性：<br>
&emsp;&emsp;如果写了4个值：
```
    padding:30px 20px 40px 100px;
```
&emsp;&emsp;`上、右、下、左`<br>

&emsp;&emsp;如果只写3个值：
```
    padding: 20px 30px 40px;
```
&emsp;&emsp;上、右、下、??和右一样,即`缺少的就跟对面的一样`。<br>

&emsp;&emsp;也就是说，
```
    padding: 30px 40px;
```

&emsp;&emsp;等价于：
```
    padding-top: 30px;
    padding-bottom: 30px;
    padding-left: 40px;
    padding-right: 40px;
```

&emsp;&emsp;要懂得，`用小属性层叠大属性`：
```
    padding: 20px;
    padding-left: 30px;
```

&emsp;&emsp;下面的写法错误：<br>
```
    padding-left: 30px;
    padding: 20px;
```
&emsp;&emsp;`不能把小属性，写在大属性前面`。<br>

- - -
#### border
&emsp;&emsp;就是`边框`。边框有三个要素：`粗细、线型、颜色`。<br>
&emsp;&emsp;颜色如果不写，默认是`黑色`。另外两个属性不写，则`显示不出`来边框。
```
    border: 1px dashed red;
```

&emsp;&emsp;border是一个大综合属性，
```
    border:1px solid red;
```
&emsp;&emsp;就是把4个边框，都设置为1px宽度、线型实线、red颜色。<br>

&emsp;&emsp;border属性能够被拆开，有两大种拆开的方式：<br>
&emsp;&emsp;1） 按3要素:`border-width`、`border-style`、`border-color`<br>
&emsp;&emsp;2） 按方向：`border-top`、`border-right`、`border-bottom`、`border-left`<br>

&emsp;&emsp;按3要素拆开：
```
    border-width:10px;    → 边框宽度
    border-style:solid;     → 线型
    border-color:red;      → 颜色。
```

&emsp;&emsp;等价于：
```
    border:10px solid red;
```

&emsp;&emsp;现在心里要明白，原来一个border是由三个小属性综合而成：<br>
&emsp;&emsp;`border-width`  `border-style`   `border-color`。<br>

&emsp;&emsp;如果某一个小要素后面是空格隔开的多个值，那么就是上右下左的顺序：
```
    border-width:10px 20px;
    border-style:solid dashed dotted;
    border-color:red green blue yellow;
```

&emsp;&emsp;按方向来拆
```
    border-top:10px solid red;
    border-right:10px solid red;
    border-bottom:10px solid red;
    border-left:10px solid red;
```

&emsp;&emsp;等价于
```
    border:10px solid red;
```

&emsp;&emsp;按方向还能再拆一层，就是把每个方向的，每个要素拆开，一共12条语句：
```
    border-top-width:10px;
    border-top-style:solid;
    border-top-color:red;
    border-right-width:10px;
    border-right-style:solid;
    border-right-color:red;
    border-bottom-width:10px;
    border-bottom-style:solid;
    border-bottom-color:red;
    border-left-width:10px;
    border-left-style:solid;
    border-left-color:red;
```

&emsp;&emsp;等价于
```
    border:10px solid red;
```

&emsp;&emsp;border可以没有，
```
    border:none;
```

&emsp;&emsp;某一条边没有：
```
    border-left: none;
```

&emsp;&emsp;也可以调整左边边框的宽度为0：
```
    border-left-width: 0;
```

- - - 
#### 标准文档流
&emsp;&emsp;我们要看看标准流有哪些微观现象：<br>
&emsp;&emsp;1） 空白折叠现象：<br>
&emsp;&emsp;比如，如果我们想让img标签之间没有空隙，必须紧密连接：
```
<img src="images/0.jpg" /><img src="images/1.jpg" /><img src="images/2.jpg" />
```
&emsp;&emsp;2） 高矮不齐，底边对齐；<br>

&emsp;&emsp;3） 自动换行，一行写不满，换行写。<br>

- - -
#### 块级元素和行内元素
&emsp;&emsp;学习的初期，你就要知道，标准文档流等级森严。标签分为两种等级：<br>

&emsp;&emsp;1） `块级元素`<br>
&emsp;&emsp;● 霸占一行，不能与其他任何元素并列<br>
&emsp;&emsp;● 能接受宽、高<br>
&emsp;&emsp;● 如果不设置宽度，那么宽度将默认变为父亲的100%。<br>

&emsp;&emsp;2） `行内元素`<br>
&emsp;&emsp;● 与其他行内元素并排<br>
&emsp;&emsp;● 不能设置宽、高。默认的宽度，就是`文字的宽度`。<br>

&emsp;&emsp;在HTML中，我们已经将标签分过类，当时分为了：文本级、容器级。<br>
&emsp;&emsp;`文本级`：`p、span、a、b、i、u、em`<br>
&emsp;&emsp;`容器级`：`div、h系列、li、dt、dd`<br>

&emsp;&emsp;CSS的分类和上面的很像，就`p`不一样：<br>
&emsp;&emsp;`所有的文本级标签，都是行内元素`，除了p，`p是个文本级，但是是个块级元素`。<br>
&emsp;&emsp;`所有的容器级标签都是块级元素`。<br>

- - -
#### 块级元素和行内元素的相互转换
&emsp;&emsp;块级元素可以设置为行内元素<br>
&emsp;&emsp;行内元素可以设置为块级元素
```
    div{
        display: inline;
        background-color: pink;
        width: 500px;
        height: 500px;
    }
```

&emsp;&emsp;`display`是“`显示模式`”的意思，用来改变元素的行内、块级性质<br>
&emsp;&emsp;`inline`就是“`行内`”。<br>

&emsp;&emsp;一旦，给一个标签设置
```
    display: inline;
```
&emsp;&emsp;那么，这个标签将立即变为行内元素。此时它和一个span无异：<br>
&emsp;&emsp;● 此时这个div不能设置宽度、高度；<br>
&emsp;&emsp;● 此时这个div可以和别人并排了<br><br>

&emsp;&emsp;同样的道理，
```
    span{
        display: block;
        width: 200px;
        height: 200px;
        background-color: pink;
        }
```

&emsp;&emsp;“`block`”是“`块`”的意思<br>

&emsp;&emsp;让标签变为块级元素。此时这个标签，和一个div无异：<br>
&emsp;&emsp;● 此时这个span能够设置宽度、高度<br>
&emsp;&emsp;● 此时这个span必须霸占一行了，别人无法和他并排<br>
&emsp;&emsp;● 如果不设置宽度，将撑满父亲<br><br>

&emsp;&emsp;标准流里面限制非常多，标签的性质恶心。比如，我们现在就要并排、并且就要设置宽高。<br>
&emsp;&emsp;所以，移民！脱离标准流！<br>

&emsp;&emsp;css中一共有三种手段，使一个元素`脱离标准文档流`：<br>
&emsp;&emsp;1） `浮动`<br>
&emsp;&emsp;2） `绝对定位`<br>
&emsp;&emsp;3） `固定定位`<br>

- - -
### 浮动
&emsp;&emsp;浮动是css里面布局用得最多的属性。
```
    .box1{
        float: left;
        width: 300px;
        height: 400px;
        background-color: yellowgreen;
    }
    .box2{
        float: left;
        width: 400px;
        height: 400px;
        background-color: skyblue;
    }
```
&emsp;&emsp;两个元素并排了，并且两个元素都能够设置宽度、高度了（这在刚才的标准流中，不能实现）。<br>
&emsp;&emsp;浮动想学好，一定要知道三个性质。

#### **浮动的元素脱标**
&emsp;&emsp;证明1：
![元素脱标]({{ site.url }}/images/20170807/float.png)

&emsp;&emsp;证明2：<br>
&emsp;&emsp;一个span标签不需要转成块级元素，就能够设置宽度、高度了。所以能够证明一件事儿，就是所有标签已经不区分行内、块了。也就是说，一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。
```
    span{
        float: left;
        width: 200px;
        height: 200px;
        background-color: orange;
    }
```

#### **浮动的元素互相贴靠**
&emsp;&emsp;如果有足够空间，那么就会靠着2号标签。如果没有足够的空间，那么会靠着1号标签。<br>
&emsp;&emsp;如果没有足够的空间靠着1号标签，自己去贴左墙。
![元素贴靠]({{ site.url }}/images/20170807/float1.png)

&emsp;&emsp;右浮动：`float:right; `
![元素贴靠]({{ site.url }}/images/20170807/float2.png)


#### 浮动的元素有“字围”效果
```
    <div>
       <img src="images/1.jpg" alt="" />
    </div>
    <p>123文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字文字
    </p>
```
&emsp;&emsp;让div浮动，p不浮动：<br>
 
&emsp;&emsp;div挡住了p，但是p中的文字不会被挡住，形成“字围”效果。<br>

&emsp;&emsp;关于浮动我们要强调一点，浮动这个东西，我们在初期一定要遵循一个原则：<br>
&emsp;&emsp;`永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。`<br>

- - -
#### 浮动性质的总结
&emsp;&emsp;浮动的性质：`脱标、贴边、字围、收缩`。<br>
&emsp;&emsp;收缩：一个浮动的元素，如果没有设置`width`，那么将自动收缩为`文字的宽度`（这点非常像行内元素）。<br>
&emsp;&emsp;整个网页，就是通过`浮动`，来实现`并排`的。

- - -
### 浮动的清除
### 清除浮动方法1：给浮动的元素的祖先元素加高度。
&emsp;&emsp;如果一个元素要浮动，那么它的`祖先元素一定要有高度`。有高度的盒子，才能关住浮动。<br>
&emsp;&emsp;只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。

- - - 
#### 清除浮动方法2：clear:both;
&emsp;&emsp;网页制作中，高度height很少出现。为什么？因为能被内容撑高！那也就是说，刚才我们讲解的方法1，工作中用的很少。
```
    clear:both;
```
&emsp;&emsp;clear就是清除，both指的是左浮动、右浮动都要清除。意思就是：清除别人对我的影响。<br>
&emsp;&emsp;这种方法有一个非常大的、致命的问题，`margin失效`了。

- - - 
#### 清除浮动方法3：隔墙法
```
    <div class="box1">
        <ul>
            <li>HTML</li>
            <li>CSS</li>
            <li>JS</li>
            <li>HTML5</li>
            <li>设计模式</li>
        </ul>
    </div>
      
    <div class="cl h16"></div>
  
    <div class="box2">
        <ul>
            <li>学习方法</li>
            <li>英语水平</li>
            <li>面试技巧</li>
        </ul>
    </div>
```

```
    .cl{
        clear: both;
    }
    .h16{
        height: 16px;
    }
```


&emsp;&emsp;近些年，有演化出了“内墙法”：
```
    <div class="box1">
        <ul>
            <li>HTML</li>
            <li>CSS</li>
            <li>JS</li>
            <li>HTML5</li>
            <li>设计模式</li>
        </ul>

        <div class="cl h16"></div>
    </div>
      
    <div class="box2">
        <ul>
            <li>学习方法</li>
            <li>英语水平</li>
            <li>面试技巧</li>
        </ul>
    </div>
```

- - - 
#### 清除浮动方法4：overflow:hidden;
&emsp;&emsp;overflow就是“溢出”的意思， hidden就是“隐藏”的意思。
```
   overflow:hidden; 
```
&emsp;&emsp;&emsp;&emsp;表示“溢出隐藏”。所有溢出边框的内容，都要隐藏掉。<br>
&emsp;&emsp;本意就是清除溢出到盒子外面的文字。但是，前端开发工程师又发现了，它能做偏方。<br>

&emsp;&emsp;一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上overflow:hidden;那么，父亲就能被儿子撑出高了。这是一个偏方。

- - - 
#### 清除浮动总结与案例
&emsp;&emsp;总结一下：<br>
&emsp;&emsp;1） 加高法：<br>
&emsp;&emsp;浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。但是，工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。
```
    <div>   → 设置height
       <p></p>
       <p></p>
       <p></p>   </div>
   
    <div>   → 设置height
       <p></p>
       <p></p>
       <p></p>
    </div>
```

&emsp;&emsp;2) `clear:both;`法<br>
&emsp;&emsp;最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。
``` 
    <div>
        <p></p>
        <p></p>
        <p></p>   </div>      <div>   → clear:both;
        <p></p>
        <p></p>
        <p></p>
   </div>
```
&emsp;&emsp;浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。<br>

&emsp;&emsp;3）隔墙法：<br>
&emsp;&emsp;在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。<br>
&emsp;&emsp;墙用自己的身体当做了间隙。
```
   <div>
        <p></p>
        <p></p>
        <p></p>
    </div>
   
    <div class="cl h10"></div>
   
    <div>
        <p></p>
        <p></p>
        <p></p>
    </div>
```
&emsp;&emsp;我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动的根据自己的儿子，撑出高度，我们就要想一些“小伎俩”，“奇淫技巧”。<br>

&emsp;&emsp;内墙法：
```
    <div>
        <p></p>
        <p></p>
        <p></p>
        <div class="cl h10"></div>
    </div>
    
    <div>
        <p></p>
        <p></p>
      <p></p>
    </div>
```
&emsp;&emsp;内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。<br>

&emsp;&emsp;4）overflow:hidden;<br>
&emsp;&emsp;这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。<br>
&emsp;&emsp;我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的小偏方。<br>
&emsp;&emsp;并且,`overflow:hidden;能够让margin生效`。

- - - 
#### 浏览器兼容问题
&emsp;&emsp;第一，IE6，不支持`小于12px的盒子`，任何小于12px的盒子，在IE6中看都大<br>
&emsp;&emsp;解决办法很简单，就是将盒子的字号，设置小（小于盒子的高），比如0px。
```
   height: 4px;
   _font-size: 0px;
```
&emsp;&emsp;我们现在介绍一下浏览器hack。hack就是“黑客”，就是使用浏览器提供的后门，针对某一种浏览器做兼容。<br><br>
&emsp;&emsp;IE6留了一个后门，就是只要给css属性之前，加上下划线，这个属性就是IE6认识的专有属性。<br>
&emsp;&emsp;比如：
```
   _background-color: green;
```

&emsp;&emsp;解决微型盒子，正确写法：
```
   height: 10px;
   _font-size:0;
```

&emsp;&emsp;第二，IE6不支持用overflow:hidden;来清除浮动的<br>
&emsp;&emsp;解决办法，以毒攻毒。追加一条
```
   _zoom:1;
```

&emsp;&emsp;完整写法：
```   
    overflow: hidden;
      _zoom:1;
```

&emsp;&emsp;实际上，`_zoom:1;`能够触发浏览器`hasLayout`机制。这个机制，不要深究了，因为`就IE6有`。我们只需要让IE6好用，具体的实现机制，有兴趣的同学，自行百度。<br>

&emsp;&emsp;强调一点，`overflow:hidden;`的本意，就是溢出盒子的border的东西隐藏，这个功能是IE6兼容的。不兼容的是`overflow:hidden;清除浮动`的时候。<br>

&emsp;&emsp;我们刚才学习了两个IE6的兼容问题，这两个IE6的兼容问题，都是通过多写一条hack来解决的。<br>
&emsp;&emsp;这个我们称为`伴生属性`。
```
   height:6px;
   _font-size:0;

   overflow:hidden;
   _zoom:1;
```

- - - 
### margin
#### margin的塌陷现象
&emsp;&emsp;`标准文档流中`，`竖直方向`的`margin不叠加`，以`较大`的为准<br>

&emsp;&emsp;如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的：

- - - 
#### 盒子居中 margin:0 auto;
&emsp;&emsp;margin的值可以为`auto，表示自动`。当left、right两个方向，都是auto的时候，盒子`居中`了：
``` 
    margin-left: auto;
    margin-right: auto;
```

&emsp;&emsp;简写为
``` 
   margin:0 auto;
```

&emsp;&emsp;注意：<br>
&emsp;&emsp;1） 使用`margin:0 auto;` 的盒子，`必须有width，有明确的width`<br><br>
&emsp;&emsp;2） 只有`标准流`的盒子，才能使用`margin:0 auto; `居中。<br>
&emsp;&emsp;也就是说，`当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto;`<br>
&emsp;&emsp;3） `margin:0 auto;是在居中盒子`，不是居中文本。<br>
&emsp;&emsp;文本的居中，要使用
```
    text-align:center;

    margin:0 auto;   → 让这个div自己在大容器中居中。
    text-align: center;  → 让这个div内部的文本居中。
```

&emsp;&emsp;普及一下知识，text-align还有
```
    text-align:left;     没啥用，因为默认居左
    text-align:right;    文本居右
```

- - -
#### `善于使用父亲的padding，而不是儿子的margin`
&emsp;&emsp;如果父亲没有border，那么儿子的margin实际上踹的是“`流`”，踹的是这“行”。所以，父亲整体也掉下来了<br>
&emsp;&emsp;这个p有一个`margin-top`踹父亲，试图将自己下移
```
    <div>
        <p></p>
    </div>
```
&emsp;&emsp;结果：<br>
&emsp;&emsp;`margin`这个属性，本质上描述的是`兄弟和兄弟之间的距离`；<br>最好不要用这个marign表达父子之间的距离。<br>
&emsp;&emsp;所以，我们一定要善于使用`父亲的padding`，而不是`儿子的margin`。

- - -

#### 关于margin的IE6兼容问题
&emsp;&emsp;当出现连续浮动的元素，携带和浮动方向相同的margin时，队首的元素，会双倍marign。<br><br>
&emsp;&emsp;解决方案：<br>
&emsp;&emsp;1）使浮动的方向和margin的方向，相反。<br>
&emsp;&emsp;所以，你就会发现，我们特别喜欢，浮动的方向和margin的方向相反。并且，前端开发工程师，把这个当做习惯了。

```
    float: left;
    margin-right: 40px;
```

&emsp;&emsp;2）使用hack（没必要，别惯着这个IE6）
&emsp;&emsp;单独给队首的元素，写一个一半的margin

```
   <li class="no1"></li>

   ul li.no1{
       _margin-left:20px;3 
   }
```
 
&emsp;&emsp;IE6的3px bug<br>

&emsp;&emsp;解决办法：<br>
&emsp;&emsp;不用管，因为根本就不允许用儿子踹父亲。所以，如果你出现了3px bug，说明你的代码不标准。

- - -

### Fireworks和精确盒子还原

```
   line-height
```

&emsp;&emsp;属性。顾名思义，就是`行的高度`。<br>

&emsp;&emsp;首行空两个汉字的格，单位比较奇怪，叫做`em`，`em就是汉字的一个宽度`。

```
   text-indent:2em;
```

&emsp;&emsp;`indent`就是“`缩进`”的意思。<br>

- - -

### 行高和字号
#### 行高
&emsp;&emsp;CSS中，所有的行，都有行高。盒模型的padding，绝对不是直接作用在文字上的，而是作用在“行”上的。
```
    line-height: 40px;
```

&emsp;&emsp;文字，是在自己的行里面居中的。比如，现在文字字号14px，行高是24px。那么：
![行高]({{ site.url }}/images/20170807/line_height.png)
&emsp;&emsp;为了严格保证字在行里面居中，我们的工程师有一个约定：<br> 
&emsp;&emsp;`行高、字号，一般都是偶数。`这样，它们的差，就是偶数，就能够被2整除。

- - -

#### 单行文本垂直居中
&emsp;&emsp;文本在行里面居中<br>
&emsp;&emsp;公式：<br>
&emsp;&emsp;`行高=盒子高`;

&emsp;&emsp;需要注意的是，这个小技巧，行高=盒子高。`只适用于单行文本垂直居中！！不适用于多行。`<br>
&emsp;&emsp;如果想让多行文本垂直居中，需要设置盒子的`padding`：
![多行文本]({{ site.url }}/images/20170807/line_height1.png)

- - - 
#### font属性
&emsp;&emsp;● 使用`font`属性，能够将`字号、行高、字体`，能够一起设置。
```
    font: 14px/24px “宋体”;
```

&emsp;&emsp;等价于三行语句：
```
    font-size:14px;
    line-height:24px;
    font-family:"宋体";
```

&emsp;&emsp;`font-family`就是“`字体`”。<br>
&emsp;&emsp;● 网页中不是所有字体都能用哦，因为这个字体要看用户的电脑里面装没装，比如你设置：<br>
&emsp;&emsp;font-family: "华文彩云";<br>
&emsp;&emsp;如果用户电脑里面没有这个字体，那么就会变成`宋体`。<br><br>

&emsp;&emsp;页面中，中文我们只使用： `微软雅黑、宋体、黑体`。 如果页面中，需要其他的字体，那么需要`切图`。<br>
&emsp;&emsp;英语：`Arial 、 Times New Roman`<br>

&emsp;&emsp;● 为了防止用户电脑里面，没有微软雅黑这个字体。就要用英语的逗号，隔开`备选字体`，就是说如果用户电脑里面，没有安装微软雅黑字体，那么就是宋体：
```
    font-family: "微软雅黑","宋体";
```
&emsp;&emsp;备选字体可以有`无数个`，用`逗号`隔开。<br>

&emsp;&emsp;● `我们要将英语字体，放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体：`
```
    font-family: "Times New Roman","微软雅黑","宋体";
```

&emsp;&emsp;● 所有的中文字体，都有英语别名，我们也要知道<br>：
&emsp;&emsp;微软雅黑的英语别名：

```
    font-family: "Microsoft YaHei";   
```

&emsp;&emsp;宋体的英语别名：<br>

```
    font-family: "SimSun";
```

&emsp;&emsp;font属性能够将`font-size、line-height、font-family`合三为一：<br>

```
    font:12px/30px  "Times New Roman","Microsoft YaHei","SimSun";
```

&emsp;&emsp;● 行高可以用百分比，表示字号的百分之多少。一般来说，都是大于100%的，因为行高一定要大于字号。

```
    font:12px/200% “宋体”
```

&emsp;&emsp;等价于

```
    font:12px/24px “宋体”;
```

&emsp;&emsp;反过来，比如：

```
    font:16px/48px “宋体”;
```

&emsp;&emsp;等价于

```
    font:16px/300% “宋体”
```

### 超级链接的美化
#### 伪类
&emsp;&emsp;也就是说，`同一个标签，根据用户的某种状态不同，有不同的样式`。这就叫做“`伪类`”。<br>
&emsp;&emsp;类就是工程师加的，比如div属于box类，很明确，就是属于box类。但是a属于什么类？不明确。因为要看用户有没有点击、有没有触碰。所以，就叫做“伪类”。<br>
&emsp;&emsp;伪类用`冒号`来表示。<br>
&emsp;&emsp;a标签有4种伪类，要求背诵：

```
        a:link{
            color:red;
        }
        a:visited{
            color:orange;
        }
        a:hover{
            color:green;
        }
        a:active{
            color:black;
        }
```

&emsp;&emsp;`:link`   表示， 用户没有点击过这个链接的样式。 是英语“链接”的意思。<br>
&emsp;&emsp;`:visited`    表示， 用户访问过了这个链接的样式。 是英语“访问过的”的意思。<br>
&emsp;&emsp;`:hover`  表示， 用户鼠标悬停的时候链接的样式。 是英语“悬停”的意思。<br>
&emsp;&emsp;`:active` 表示， 用户用鼠标点击这个链接，但是不松手，此刻的样式。 是英语“激活”的意思。<br>
&emsp;&emsp;记住，这四种状态，在css中，必须按照固定的顺序写：<br>
&emsp;&emsp;`a:link 、a:visited 、a:hover 、a:active`<br>
&emsp;&emsp;如果不按照顺序，那么将失效。“爱恨准则”love hate。必须先爱，后恨。

- - -
 
#### 超级链接的美化
&emsp;&emsp;a标签在使用的时候，非常的难。因为不仅仅要控制a这个盒子，也要控制它的伪类。<br><br>
&emsp;&emsp;我们一定要将a标签写在前面，:link、:visited、:hover、:active这些伪类写在后面。<br><br>
&emsp;&emsp;a标签中，描述盒子； 伪类中描述文字的样式、背景。

```
        .nav ul li a{
            display: block;
            width: 120px;
            height: 40px;
        }
        .nav ul li a:link ,.nav ul li a:visited{
            text-decoration: none;
            background-color: yellowgreen;
            color:white;
        }
        .nav ul li a:hover{
            background-color: purple;
            font-weight: bold;
            color:yellow;
        }
```

&emsp;&emsp;记住，`所有的a不继承text、font这些东西`。因为a自己有一个伪类的权重。<br>

&emsp;&emsp;最标准的，就是把link、visited、hover都要写。但是前端开发工程师在大量的实践中，发现不写link、visited浏览器也挺兼容。所以这些“老油条”们，就把a标签简化了：<br>
&emsp;&emsp;a:link、a:visited都是可以省略的，简写在a标签里面。也就是说，a标签涵盖了link、visited的状态。
```
        .nav ul li a{
            display: block;
            width: 120px;
            height: 50px;
            text-decoration: none;
            background-color: purple;
            color:white;
        }
        .nav ul li a:hover{
            background-color: orange;
        }
```

- - - 

### background系列属性
#### background-color属性
&emsp;&emsp;背景颜色属性。<br>
&emsp;&emsp;css2.1中，颜色的表示方法有哪些？一共有三种：`单词、rgb表示法、十六进制表示法`<br>
&emsp;&emsp;* 用英语单词来表示<br>
&emsp;&emsp;能够用英语单词来表述的颜色，都是简单颜色。<br>
&emsp;&emsp;红色：

```
    background-color: red;   
```

- 用rgb方法来表示
&emsp;&emsp;红色：
```
    background-color: rgb(255,0,0);
```

- 十六进制表示法
&emsp;&emsp;红色：
```
    background-color: #ff0000;
```
所有用#开头的值，都是16进制的。<br>
`#ff0000`

&emsp;&emsp;所以，任何一种十六进制表示法，都能够换算成为rgb表示法。也就是说，两个表示法的颜色数量，一样。<br>

&emsp;&emsp;十六进制可以`简化为3位`，所有#aabbcc的形式，能够简化为#abc;<br>

- - -

#### background-image
&emsp;&emsp;用于给盒子加上背景图片：
```
    background-image:url(images/wuyifan.jpg);
```

&emsp;&emsp;url()表示网址，uniform resouces locator 统一资源定位符<br>
&emsp;&emsp;`images/wuyifan.jpg` 就是相对路径。<br>
&emsp;&emsp;背景天生是会被`平铺`满的。<br>

&emsp;&emsp;`padding的区域有背景图`。

- - -
#### background-repeat属性
&emsp;&emsp;设置背景图`是否重复的，重复方式的`。<br>
&emsp;&emsp;也就是说，`background-repeat`属性，有`三`种值：
```
background-repeat:no-repeat;   不重复
background-repeat:repeat-x;    横向重复
background-repeat:repeat-y;    纵向重复
```

- - - 
#### background-position属性
&emsp;&emsp;* 属性的意思<br>
&emsp;&emsp;`背景定位属性`，是最难的属性。<br>
![背景定位]({{ site.url }}/images/20170807/bg_position.png)
&emsp;&emsp;position就是“位置”的意思。background-position就是背景定位属性。

```
    background-position:向右移动量 向下移动量;
```

&emsp;&emsp;定位属性`可以是负数`：<br>

- - -
#### css精灵
&emsp;&emsp;原理：<br>
&emsp;&emsp;“css精灵”，英语css sprite，所以也叫做“css雪碧”技术。是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。<br>
&emsp;&emsp;css精灵有什么优点，就是减少了http请求。比如4张小图片，原本需要4个http请求。但是用了css精灵，小图片变为了一张图，http请求只有1个了。

- - -
#### 用单词描述
&emsp;&emsp;background-position: 描述左右的词儿  描述上下的词儿;<br>
&emsp;&emsp;描述左右的词儿： `left、 center、right`<br>
&emsp;&emsp;描述上下的词儿： `top 、center、bottom`<br>

&emsp;&emsp;所以：<br>
&emsp;&emsp;右下角：<br>

```
    background-position: right bottom;
```

&emsp;&emsp;左下角：

```
    background-position: left bottom;
```

- - - 

#### background-attachment
&emsp;&emsp;背景`是否固定`。
```
    background-attachment:fixed;
```
&emsp;&emsp;背景就会被固定住，`不会被滚动条滚走`。

- - - 
#### background综合属性
&emsp;&emsp;background属性和border一样，是一个综合属性：

```
    background:red url(1.jpg) no-repeat 100px 100px fixed;
```

&emsp;&emsp;等价于：

```
    background-color:red;
    background-image:url(1.jpg);
    background-repeat:no-repeat;
    background-position:100px 100px;
    background-attachment:fixed;
```

&emsp;&emsp;可以任意省略部分：

```
    background: red;

    background: blue url(images/wuyifan.jpg) no-repeat 100px 100px;
```

&emsp;&emsp;精灵的使用：

```
    background: url(images/taobao.png) no-repeat 0 -133px;
```

- - - 

### 相对定位
&emsp;&emsp;定位有三种，分别是`相对定位、绝对定位、固定定位`。<br>

&emsp;&emsp;相对定位：

```
    position:relative;
```

&emsp;&emsp;绝对定位：

```
    position:absolute;
```

&emsp;&emsp;固定定位：

```
    position:fixed;
```

- - -

#### 认识相对定位
&emsp;&emsp;相对定位，就是微调元素位置的。让元素`相对自己原来的位置`，进行位置调整。
![相对定位]({{ site.url }}/images/20170807/relative.png)

&emsp;&emsp;也就是说，如果一个盒子想`进行位置调整`，那么就要使用相对定位

```
    position:relative;   → 必须先声明，自己要相对定位了，
    left:100px;       → 然后进行调整。
    top:150px;       → 然后进行调整。
```

#### 不脱标，老家留坑，形影分离
&emsp;&emsp;相对定位`不脱标`，`真实位置是在老家`，只不过影子出去了，可以到处飘。
![相对定位]({{ site.url }}/images/20170807/relative1.png)

#### 相对定位用途
&emsp;&emsp;相对定位有坑，所以一般不用于做“压盖”效果。页面中，效果极小。就两个作用：<br>
&emsp;&emsp;1） 微调元素<br>
&emsp;&emsp;2） 做绝对定位的参考，子绝父相（讲绝对定位的时候说）<br>

#### 相对定位的定位值
&emsp;&emsp;可以用left、right来描述盒子右、左的移动；<br>
&emsp;&emsp;可以用top、bottom来描述盒子的下、上的移动。<br>

&emsp;&emsp;↘：

```
    position: relative;
    top: 10px;
    left: 40px;
```

&emsp;&emsp;↙：

```
    position: relative;
    right: 100px;   → 往左边移动
    top: 100px;
```

&emsp;&emsp;↖：

```
    position: relative; 
    right: 100px;
    bottom: 100px;    → 移动方向是向上。
```

&emsp;&emsp;↗：

```
    position: relative;
    top: -200px;       → 负数就是相反的方向，如果是正，就是下边，如果是负数就是上边
    right: -200px; 
```
<br/>
<br/>

&emsp;&emsp;↗：

```
    position: relative;
    right: -300px;
    bottom: 300px;
```

&emsp;&emsp;完全等价于：

```
    position: relative;
    left: 300px;
    bottom: 300px;
```

- - - 

### 绝对定位
&emsp;&emsp;绝对定位比相对定位更灵活。
![绝对定位]({{ site.url }}/images/20170807/absolute.png)

#### 绝对定位脱标
&emsp;&emsp;绝对定位的盒子，是`脱离标准文档流`的。所以，`所有的标准文档流的性质，绝对定位之后都不遵守了`。<br>
&emsp;&emsp;绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要display:block;就可以设置宽、高了：

```
    span{
        position: absolute;
        top: 100px;
        left: 100px;
        width: 100px;
        height: 100px;
        background-color: pink;
    }
```

- - -

#### 参考点
&emsp;&emsp;绝对定位的参考点，如果用top描述，那么定位参考点就是`页面的左上角`，而不是浏览器的左上角：
![绝对定位]({{ site.url }}/images/20170807/absolute1.png)

&emsp;&emsp;如果用bottom描述，那么就是`浏览器首屏窗口尺寸，对应的页面的左下角`：
![绝对定位]({{ site.url }}/images/20170807/absolute2.png)

- - -

#### 以盒子为参考点
&emsp;&emsp;`一个绝对定位的元素，如果父辈元素中出现了也定位了的元素，那么将以父辈这个元素，为参考点。`
![绝对定位]({{ site.url }}/images/20170807/absolute3.png)

&emsp;&emsp;● 要听`最近的已经定位的祖先元素`的，不一定是父亲，可能是爷爷：

```
    <div class="box1">   →  相对定位
        <div class="box2">  →  没有定位
            <p></p>   → 绝对定位，将以box1为参考，因为box2没有定位，box1就是最近的父辈元素
        </div>
    </div>

    <div class="box1">   →  相对定位
        <div class="box2">  → 相对定位
            <p></p>   → 绝对定位，将以box2为参考，因为box2是自己最近的父辈元素
        </div>
    </div>
```

&emsp;&emsp;● 不一定是相对定位，`任何定位，都可以作为参考点`
```
    <div>  → 绝对定位
        <p></p>  → 绝对定位，将以div作为参考点。因为父亲定位了。
    </div>
```

&emsp;&emsp;子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是，工程上子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。工程上，`“子绝父相”有意义`，父亲没有脱标，儿子脱标在父亲的范围里面移动。
```
    <div class=”box1”>  → 绝对定位
        <div class=”box2”>  → 相对定位
            <div class=”box3”>  → 没有定位
                <p></p>  → 绝对定位，以box2为参考定位。
            </div>
        </div>
    </div>
```

&emsp;&emsp;● 绝对定位的儿子，`无视参考的那个盒子的padding。`
下图中，绿色部分是div的padding，蓝色部分是div的内容区域。那么此时，div相对定位，p绝对定位。
p将无视父亲的padding，`在border内侧为参考点，进行定位`：

- - -
#### 绝对定位的盒子居中
&emsp;&emsp;绝对定位之后，所有标准流的规则，都不适用了。所以`margin:0 auto;`失效。
```
    width: 600px;
    height: 60px;
        position: absolute;
    left: 50%;
    top: 0;
    margin-left: -300px;   → 宽度的一半
```

- - -
### 固定定位
&emsp;&emsp;固定定位，就是`相对浏览器窗口定位`。页面如何滚动，这个盒子显示的位置不变。
固定定位脱标！<br/>

&emsp;&emsp;IE6不兼容。

- - - 
### z-index
&emsp;&emsp;● z-index值表示谁压着谁。`数值大的压盖住数值小的`。<br>
&emsp;&emsp;● `只有定位了的元素，才能有z-index值。`也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而`浮动的东西不能用`。<br>
&emsp;&emsp;● z-index值`没有单位`，就是`一个正整数`。`默认的z-index值是0`。<br>
&emsp;&emsp;● `如果大家都没有z-index值，或者z-index值一样，那么谁写在HTML后面，谁在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。`<br>
&emsp;&emsp;● 从父现象：父亲怂了，儿子再牛逼也没用。<br>

- - -
## JavaScript {#javascript}
&emsp;&emsp;放在 `<head></head>` 里的会比放在 `<body></body>`先执行。head标签里的代码会在页面还未开始绘制之前被解析，而在body里的代码则会在页面渲染的同时在读取到这段代码的时候才被执行。<br/>
&emsp;&emsp;而把 JavaScript 代码放在外部文件中，只有在事件被触发，需要该段 JavaScript 代码时，才调用执行。<br/>
&emsp;&emsp;这样做有个好处，当页面比较复杂的时候，把大量的JavaScript代码放到外部文件，只有在需要的时候才执行，那么会明显地加快页面加载速度。<br/>

### 变量的声明
&emsp;&emsp;在 JavaScript 中，变量用 `var` 命令做声明：

&emsp;&emsp;字符串可以是引号中的任意文本，您可以使用单引号或双引号，也可以在字符串中使用引号，只要不匹配包围字符串的引号即可：
```
    var answer="I Love 'shiyanlou'";
    var answer='I Love "shiyanlou"';
```

&emsp;&emsp;JavaScript 只有一种数字类型。数字可以带小数点，也可以不带：

#### 数组
&emsp;&emsp;创建一个名为 boys 的数组：
```
    var boys=new Array();
    boys[0]="Tom";
    boys[1]="Jack";
    boys[2]="Alex";
```
&emsp;&emsp;也可以这样:
```
    var boys=new Array("Tom","Jack","Alex");
```

### 常用事件
&emsp;&emsp;除了刚才提到的 onclick 事件，还有这些常用的事件：

- `onclick` 单击
- `ondblclick` 双击
- `onfocus` 元素获得焦点
- `onblur` 元素失去焦点
- `onmouseover` 鼠标移到某元素之上
- `onmouseout` 鼠标从某元素移开
- `onmousedown` 鼠标按钮被按下
- `onmouseup` 鼠标按键被松开
- `onkeydown` 某个键盘按键被按下
- `onkeyup` 某个键盘按键被松开
- `onkeypress` 某个键盘按键被按下并松开

### 创建对象
&emsp;&emsp;方法1：
```
    student = new Object();  // 创建对象“student”

    student.name = "Tom";   // 对象属性 名字
    student.age  = "19";    // 对象属性 年龄

    student.study =function() {   // 对象方法 学习
        alert("studying");
    };

    student.eat =function() {     // 对象方法 吃
        alert("eating");
    };
```

&emsp;&emsp;方法2：
```
    var student = {};
    student.name = "Tom";
……

```

&emsp;&emsp;方法3：
```
    var student = {
    name:"Tom";
     age:"19";
    ……
}
```

&emsp;&emsp;方法4，采用函数的方式新建对象：
```
    function student(name,age) {

        this.name = name;
        this.age = age;

        this.study = function() {
            alert("studying");
        };

        this.eat = function() {
            alert("eating");
        }
    }
```
&emsp;&emsp;然后通过 new 创建 student 对象的实例：
```
    var student1 = new student('Tom','19');

    var student2 = new student('Jack','20');
```

- - - 
### 常用内置对象
#### String 字符串对象
&emsp;&emsp;该对象只有一个属性，即 `length`，表示字符串中的字符个数，包括所有的空格和符号：

&emsp;&emsp;String 的方法<br/>
&emsp;&emsp;String 对象共有 **19** 个内置方法，主要包括字符串在页面中的显示、字体大小、字体颜色、字符的搜索以及字符的大小写转换等功能，下面是一些常用的：

- `charAt(n)` ：返回该字符串第 n 位的单个字符。（从 0 开始计数）
- `charCodeAt(n)` ：返回该字符串第 n 位的单个字符的 ASCII 码。
- `indexOf()` ：用法：string_1.indexOf(string_2,n); 从字符串 string_1 的第 n 位开始搜索，查找 string_2，返回查找到的位置，如果未找到，则返回 -1，其中 n 可以不填，默认从第 0 位开始查找。
- `lastIndexOf()` ：跟 indexOf() 相似，不过是从后边开始找。
- `split('分隔符')` ：将字符串按照指定的分隔符分离开，返回一个数组，例如：'1&2&345&678'.split('&')；返回数组：1,2,345,678。
- `substring(n,m)` ：返回原字符串从 n 位置到 m 位置的子串。
- `substr(n,x)` ：返回原字符串从 n 位置开始，长度为 x 的子串。
- `toLowerCase()` ：返回把原字符串所有大写字母都变成小写的字符串。
- `toUpperCase()` ：返回把原字符串所有小写字母都变成大写的字符串。

- - - 
#### Math 对象
&emsp;&emsp;属性，是数学上几个常用的值：
- `E` ：返回常数 e (2.718281828...)。
- `LN2` ：返回 2 的自然对数 (ln 2)。
- `LN10` ：返回 10 的自然对数 (ln 10)。
- `LOG2E` ：返回以 2 为低的 e 的对数 (log2e)。
- `LOG10E` ：返回以 10 为低的 e 的对数 (log10e)。
- `PI` ：返回π（3.1415926535...)。
- `SQRT1_2` ：返回 1/2 的平方根。
- `SQRT2` ：返回 2 的平方根。

&emsp;&emsp;Math 的内置方法，是一些数学上常用的数学运算：
- `abs(x)` ：返回 x 的绝对值。
- `round(x)` ：返回 x 四舍五入后的值。
- `sqrt(x)` ：返回 x 的平方根。
- `ceil(x)` ：返回大于等于 x 的最小整数。
- `floor(x)` ：返回小于等于 x 的最大整数。
- `sin(x)` ：返回 x 的正弦。
- `cos(x)` ：返回 x 的余弦。
- `tan(x)` ：返回 x 的正切。
- `acos(x)` ：返回 x 的反余弦值（余弦值等于 x 的角度），用弧度表示。
- `asin(x)` ：返回 x 的反正弦值。
- `atan(x)` ：返回 x 的反正切值。
- `exp(x)` ：返回 e 的 x 次幂 (e^x)。
- `pow(n, m)` ：返回 n 的 m 次幂 (nm)。
- `log(x)` ：返回 x 的自然对数 (ln x)。
- `max(a, b)` ：返回 a, b 中较大的数。
- `min(a, b)` ：返回 a, b 中较小的数。
- `random()` ：返回大于 0 小于 1 的一个随机数。

- - -
#### Array 数组对象
&emsp;&emsp;JavaScript只有一维数组，要使用多维数组：
```
    var myArray = new Array(new Array(), new Array(), new Array(), ...);
```

&emsp;&emsp;Array 的属性
- `length` ：返回数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一。

&emsp;&emsp;因此，想添加一个元素，只需要：
```
    myArray[myArray.length] = ...;
```

&emsp;&emsp;Array 的方法
- `join("指定分隔符")` ：返回一个字符串，把数组元素串起来，元素间用指定分隔符隔开。
- `toString()` ：把数组转为字符串，并返回结果。
- `reverse()` ：使数组元素倒序。
- `slice(n,m)` ：返回子数组，从数组第 n 个元素到第 m 个元素。
- `sort(SortFunction)` ：按照指定的 SortFunction 将数组的元素排序。
- `concat(Array_1,Array_2)` ：用于连接两个或多个数组。

- - - 
### DOM
#### 基本概念
&emsp;&emsp;DOM 是 文档对象模型（Document Object Model）的简称，它的基本思想是把结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口，以达到使用编程语言操作文档的目的，所以，DOM 可以理解成文档（HTML 文档、XML 文档）的编程接口。

&emsp;&emsp;严格地说，DOM 不属于 JavaScript，但是操作 DOM 是 JavaScript 最常见的任务，而 JavaScript 也是最常用于 DOM 操作的语言，本章介绍的就是 JavaScript 对 DOM 标准的实现和用法。

#### 几种对象
##### Node
&emsp;&emsp;DOM 的最小组成单位叫做节点（node），一个文档的树形结构（DOM 树），就是由各种不同类型的节点组成。

对于 HTML 文档，节点主要有以下六种类型：

| 节点             |名称       |含义                              |
|      -          |    -      |    -   
|Document         |文档节点    |整个文档（window.document）        |
|DocumentType     |文档类型节点 | 文档的类型                        |
|Element          |元素节点    |HTML 元素（比如<head>、<body>等）   |
|Attribute        |属性节点    |HTML 元素的属性（比如 class="right"）|
|Text             |文本节点    |HTML 文档中出现的文本               |
|DocumentFragment |文档碎片节点 | 文档的片段                        |

- - -
##### NodeList
&emsp;&emsp;NodeList 对象是一个节点的集合，一般由 Node.childNodes 、 document.getElementsByName 和 document.querySelectorAll 返回的。

&emsp;&emsp;不过需要注意， Node.childNodes 、 document.getElementsByName 返回的 NodeList 的结果是实时的（此时跟HTMLCollection比较类似），而 document.querySelectorAll 返回的结果是固定的，这一点比较特殊。

##### HTMLCollection
&emsp;&emsp;HTMLCollection是一个特殊的NodeList，表示包含了若干元素（元素顺序为文档流中的顺序）的通用集合，它是实时更新的，当其所包含的元素发生改变时，它会自动更新。另外，它是一个伪数组，如果想像数组一样操作它们需要像 Array.prototype.slice.call(nodeList, 2) 这样调用。

- - -
#### 选取文档元素
##### 通过 ID 选取元素

&emsp;&emsp;我们可以使用方法 `getElementById()` 通过元素的 `ID` 而选取元素，并对其做操作，比如：
```
    <html>
    <body>
    <div id="my_div"></div>

    <script>
        document.getElementById("my_div").style.height="100px";  // 设置 my_div 高度为 100px
        document.getElementById("my_div").style.background="red"; // 设置 my_div 颜色为 红色
    </script>

    </body>
    </html>
```
&emsp;&emsp;通过 getElementByID() 设置了 ID 为 my_div 的一个 div 标签的高度（100px）和颜色（red）

##### 通过名字（Name）或标签名（TagName）选取元素

&emsp;&emsp;除了通过 ID 选择元素，我们还可以使用 `getElementsByName()` 方法或者 `getElementsByTagName()` 方法找到元素，不过如果有多个同类型标签，那我们需要以`下标`来确认：
```
    <html>
    <body>
    <input type="text" />
    <input type="text" />

    <script>
    document.getElementsByTagName("input")[0].value="hello";   // 下标为 [0] 表示选取第 1 个 input 标签
    document.getElementsByTagName("input")[1].value="shiyanlou"; // 下标为 [1] 表示选取第 2 个 input 标签
    </script>

    </body>
    </html>
```

##### document.getElementsByClassName
&emsp;&emsp;根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；

##### document.querySelector
&emsp;&emsp;返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。

##### document.querySelectorAll
&emsp;&emsp;返回一个 NodeList ，IE8+(含）。

##### document.forms
&emsp;&emsp;获取当前页面所有form，返回一个 HTMLCollection ；

- - -
#### 创建文档节点
##### createElement

&emsp;&emsp;JavaScript 可以动态地在页面中创建并插入节点，这便需要用到 `createElement()、appendChild()` 方法，它们的作用分别是创建节点和插入节点。

&emsp;&emsp;比如：创建一个 div 并为其设置高度（100px）和背景色（red），并追加到 body 后面：
```
    <html>
        <body>
            <div style="background:#00F; height:100px"></div>

            <script>
                var mydiv = document.createElement("div");
                mydiv.style.height = "100px";
                mydiv.style.background = "red";
                document.getElementsByTagName("body")[0].appendChild(mydiv);
            </script>
        </body>
    </html>
```

##### createTextNode
&emsp;&emsp;创建文本节点：
```
    var node = document.createTextNode("我是文本节点");  
    document.body.appendChild(node); 
```

##### cloneNode
&emsp;&emsp;克隆一个节点： `node.cloneNode(true/false)` ，它接收一个bool参数，用来表示`是否复制子元素`。
```
    var from = document.getElementById("test");  
    var clone = from.cloneNode(true);  
    clone.id = "test2";  
    document.body.appendChild(clone);  
```
&emsp;&emsp;克隆节点并不会克隆事件，除非事件是用 `<div onclick="test()"></div> `这种方式绑定的，用 `addEventListener` 和 `node.onclick=xxx;` 方式绑定的都不会复制。

##### createDocumentFragment
&emsp;&emsp;本方法用来创建一个 DocumentFragment ，也就是文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，大量操作DOM时用它可以大大提升性能。

- - -
#### 修改文档节点
##### appendChild
&emsp;&emsp;这个其实前面已经多次用到了，语法就是：
```
    parent.appendChild(child);
```

&emsp;&emsp;它会将child追加到parent的子节点的最后面。另外，如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到新的位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，且其事件会保留。

##### insertBefore
将某个节点插入到另外一个节点的前面，语法：
```
    parentNode.insertBefore(newNode, refNode); 
```

##### removeChild
&emsp;&emsp;removeChild用于删除指定的子节点并返回子节点，语法：
```
    var deletedChild = parent.removeChild(node);  
```

##### replaceChild用于将一个节点替换另一个节点，语法：
```
    parent.replaceChild(newChild, oldChild);  
```

- - -
#### 节点关系
##### 父关系API
&emsp;&emsp;`parentNode` ：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment；
&emsp;&emsp;`parentElement` ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；

##### 子关系API
&emsp;&emsp;`children` ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；
&emsp;&emsp;`childNodes` ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；
&emsp;&emsp;`firstChild` ：返回第一个子节点，不存在返回null，与之相对应的还有一个 `firstElementChild` ；
&emsp;&emsp;`lastChild` ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 `lastElementChild` ；

##### 兄弟关系型API
&emsp;&emsp;`previousSibling` ：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。
&emsp;&emsp;`nextSibling` ：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。
&emsp;&emsp;`previousElementSibling `：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。
&emsp;&emsp;`nextElementSibling` ：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。

- - -
#### 查询和设置元素的属性
##### 直接获取CSS样式

```
    node.style.color     // 可读可写
```

##### Style本身的属性和方法

```
    node.style.cssText     //获取node行内样式字符串
    node.style.length      //获取行内样式个数
    node.style.item(0)     //获取指定位置的样式
```

##### 修改DOM特性的方法

```
    Node.getAttribute('id')    // 获取
    Node.setAttribute('id')    // 设置
    Node.removeAttribute()     // 移除
    Node.attributes        // 获取DOM全部特性
```

##### 增加类名

```
    document.getElementById('foo').className += 'bold';
```

##### 动态添加样式规则

```
    var style = document.createElement('style');  
    style.innerHTML = 'body{color:red} #top:hover{background-color: red;color: white;}';  
    document.head.appendChild(style); 
```

##### window.getComputedStyle
&emsp;&emsp;通过 element.sytle.xxx 只能获取到内联样式，借助 window.getComputedStyle 可以获取应用到元素上的所有样式，IE8或更低版本不支持此方法。

```
    var style = window.getComputedStyle(element[, pseudoElt]);  
```

##### getBoundingClientRect
&emsp;&emsp;getBoundingClientRect 用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：

```
    var clientRect = element.getBoundingClientRect();  
```
- - -
## jQuery {#jquery}
### JavaScript缺点
1. window.onload 事件有个事件覆盖的问题，只能写一个
2. 代码容错性差
3. 浏览器兼容性问题
4. 书写很繁琐，代码量多
5. 代码混乱
6. 难实现动画效果

- - -

### 基本使用
#### 版本问题
1. 1.xxx 版本    jQuery-1.11.1.js
2. 2.xxx 版本     不再支持IE6、7、8

#### 引包
&emsp;&emsp;用jQuery之前，先`引入`jQuery，然后，再去写我们的jQuery代码。

#### 入口函数

```
    //入口函数的方式：
    //1.
    $(document).ready(function(){

        });

    //2.
    $(function(){

        });

```

- - - 

### 事件处理程序
#### 事件源

&emsp;&emsp;Js方式：

```
    document.getElementById(“id”)
```

&emsp;&emsp;jQuery方式：

```
    $(“#id”)
```

#### 事件

&emsp;&emsp;Js方式:
```
    document.getElementById(“id”).onclick
```

&emsp;&emsp;jQuery方式:

```
    $(“#id”).click
```

&emsp;&emsp;区别：jQuery的事件`不带on`

#### 事件处理程序

&emsp;&emsp;Js 书写方式:

```
    document.getElementById(“id”).onclick = function(){
        // 语句
    }
```

&emsp;&emsp;jQuery 书写方式: 

```
    $(“#id”).click(function(){
        // 语句
    });
```

### 详细介绍
#### $问题
&emsp;&emsp;a)  Js命名归法：下划线、字母、$、数字<br/>
&emsp;&emsp;b)  但是不能以数字作为开头

```
    var $ = “我是$符号”;
```

&emsp;&emsp;jQUery的两个变量：`$` 和 `jQuery`<br/>
&emsp;&emsp;jQuery占用了我们两个变量：$ 和 jQuery


#### js入口函数跟jQuery入口函数的区别：

&emsp;&emsp;Js的window.onload事件是等到所有内容，以及我们的外部图片之类的文件加载完了之后，才回去执行<br/>
&emsp;&emsp;jQuery的入口函数 是在 html所有标签都加载之后，就回去执行。

&emsp;&emsp;Js创建对象

&emsp;&emsp;三种方式：
```
    1.  var obj = {};
    2.  var obj1 = new Object();
    3.  var obj2 = Object.create();
```
&emsp;&emsp;1跟2的区别：<br/>
&emsp;&emsp;推荐使用第一个方式<br/>
&emsp;&emsp;第二种方式存在效率问题，因为要new对象，会涉及到原型查找的问题。

- - -
### jQuery基本选择器
#### CSS3选择器

|符号   |说明    |用法    |
|-     |-       |-      |
|`#id`   |Id选择器 |`#id{ color:red; }`|
|`.class`|类选择器|`.class{ //}`|
|`Element`|标签选择器|`P { //}`|
|`*`|通配符选择器|配合其他选择器来使用|
|`,`|并集选择器|`div,p{}`|
|`空格`|后代选择器|`div span{}`<br/>选择div下面所有后代的span|
|`>`|子代选择器|`div > span{}`|
|`+`|紧邻选择器|`div+p`<br/>选择div紧挨着的下一个p元素|

#### jQuery基本选择器

|符号   |说明    |用法    |
|-     |-       |-      |
|`$(“#demo”)`|选择id为demo的第一个元素|`$(“#demo”).css(“background”,”red”)`|
|`$(“.liItem”)`|选择所有类名（样式名）为liItem的元素|`$(“.liItem”). css(“background”,”red”);`|
|`$(“div”)`|选择所有标签名字为div的元素|`$(“div”). css(“background”,”red”);`|
|`$(“*”)`|选择所有元素,`少用或配合其他选择器来使用`|`$(“*”). css(“background”,”red”)`|
|`$(“.liItem,div”)`|选择多个指定的元素，这个地方是选择出了 .liItem元素和div元素|`$(“.liItem,div”). css(“background”,”red”)`|

&emsp;&emsp;规律：`$(selector).css(“background”,”red”);`


- - - 
- 
### jQuery是什么
&emsp;&emsp;jQuery就是javascript的一个`库`，把我们常用的一些功能进行了封装，方便我们来调用，提高我们的开发效率。

#### Javascipt跟jQuery的区别：

- Javascript是一门编程语言，我们用它来编写客户端浏览器脚本。
- jQuery是javascript的一个库，包含多个可重用的函数，用来辅助我们简化javascript开发
- jQuery能做的javascipt都能做到，而javascript能做的事情，jQuery不一定能做到。

- - -

### jQuery其他选择器
#### 层级选择器

|符号   |说明    |用法    |
|-     |-       |-      |
|`空格`|后代选择器,选择所有的后代元素|`$(“div span”). css(“background”,”red”);`|
|`>`|子代选择器,选择所有的子代元素|`$(“div > span”). css(“background”,”red”)`|
|`+`|紧邻选择器,选择紧挨着的下一个元素|`$(“div + p”). css(“background”,”red”)`|
|`~`|兄弟选择器,选择后面的所有的兄弟元素|`$(“div ~ p”). css(“background”,”red”)`|

&emsp;&emsp;层级选择器选择了选择符 后面那个元素，比如，div  >  p，是选择>后面的p元素。

#### 过滤选择器


|符号   |说明    |用法    |
|-     |-       |-      |
|`:eq(index)`|index是从0开始的一个数字，选择序号为index的元素。选择第一个匹配的元素。|$(“li:eq(1)”). css(“background”,”red”)|
|`:gt(index)`|Index 是从0开始的一个数字，选择序号大于index的元素|$(“li:gt(2)”). css(“background”,”red”)|
|`:lt(index)`|Index是从0开始的一个数字，选择小于index 的元素|$(“li:lt(2)”). css(“background”,”red”)|
|`:odd`|选择所有序号为奇数行的元素|$(“li:odd”). css(“background”,”red”)|
|`:even`|选择所有序号为偶数的元素|$(“li:even”). css(“background”,”red”)|
|`:first`|选择匹配第一个元素|$(“li:first”). css(“background”,”red”)|
|`:last`|选择匹配的最后一个元素|$(“li:last”). css(“background”,”red”)|

#### 属性选择器

|符号   |说明    |用法    |
|-     |-       |-      |
|`$(“a[href]”)`|选择所有包含href属性的元素|$(“a[href]”). css(“background”,”red”)|
|`$(“a[href=’itcast’]”)`|选择href属性值为itcast的所有a标签|$(“a[href=’itcast’]”). css(“background”,”red”)|
|`$(“a[href!=’baidu’]”)`|选择所有href属性不等baidu的所有元素，包括没有href的元素|$(“a[href!=’baidu’]”). css(“background”,”red”)|
|`$(“a[href^=’web’]”)`|选择所有以web开头的元素|$(“a[href^=’web’]”). css(“background”,”red”)||
|`$(“a[href$=’cn’]”)`|选择所有以cn结尾的元素|$(“a[href$=’cn’]”). css(“background”,”red”)|
|`$(“a[href*=’i’]”)`|选择所有包含i这个字符的元素，可以是中英文|$(“a[href*=’i’]”). css(“background”,”red”)|
|`$(“a[href][title=’我’]”)`|选择所有符合指定属性规则的元素，都符合才会被选中。|$(“a[href][title=’我’]”). css(“background”,”red”)|

#### 筛选选择器
&emsp;&emsp;`.eq(index)`   下标为index<br/>
&emsp;&emsp;`.parent() `   父母 <br/>
&emsp;&emsp;`.children()`   孩子<br/>
&emsp;&emsp;`.sibling()`    亲兄弟姐妹，亲同胞 <br/>
&emsp;&emsp;`.next() `          选择选中元素的紧挨着的亲弟弟或妹妹<br/>
&emsp;&emsp;`.nextAll() `        选择选中元素的所有亲弟弟妹妹<br/>
&emsp;&emsp;`.prev()`           选择选中元素的紧挨着的亲哥哥或姐姐<br/>
&emsp;&emsp;`.prevAll() `        选择选中元素的所有的亲哥哥姐姐<br/>
&emsp;&emsp;`.find(选择器) `     选择选中元素的后代<br/>

#### 串联筛选选择器

&emsp;&emsp;`.end()`      返回到最近一次“破坏”之前的状<br/>
&emsp;&emsp;`.addBack()`  表示加上自身

&emsp;&emsp;jQuery 1.8以前版本用`andSelf()`，jQuery1.9后版本用`addBack()`

&emsp;&emsp;选中元素在其亲兄弟姐妹中的索引值：<br/>
&emsp;&emsp;`.index()`方法

- - -
### mouseover事件跟mouseenter事件的区别：
&emsp;&emsp;`mouseover/mouseout`事件，鼠标经过的时候会`触发多次`，每遇到一个`子元素`就会触发一次。

&emsp;&emsp;`mouseenter/mouseleave`事件，鼠标经过的时候只会触发一次

- - -
### DOM对象跟jQuery对象相互转换
&emsp;&emsp;jQuery对象转换成DOM对象:
```
    方式一：$(“#btn”)[0]
    方式二：$(“#btn”).get(0)
```

&emsp;&emsp;DOM对象转换成jQuery对象：
```
    $(document)     -> 把DOM对象转成了jQuery对象
        var btn = document.getElementById(“bt n”);
        btn     -> $(btn);
```

- - -
### DOM操作方法
#### 创建节点
##### 创建元素节点
```
    $('<div></div>');
```

##### 创建文本节点
&emsp;&emsp;创建文本节点就是在创建元素节点时直接把文本内容写出来
```
    $('<div>content</div>');
```

##### 创建属性节点
```
    $('<div id='1'>content</div>');
```

- - - 
#### 插入节点
##### 在元素前后插入
```
    <div id="1"></div>
    <div id="2"></div>
    <div id="3"></div>
```

&emsp;&emsp;创建一个新的元素，ID为’1.1’，并且插入到第一个和第二个DIV之间
```
    $('#1').after('<div id="1.1"></div>');
```

&emsp;&emsp;或者：
```
    $('#2').before('<div id="1.1"></div>');
```

&emsp;&emsp;结果为：
```
    <div id="1"></div>
    <div id="1.1"></div>
    <div id="2"></div>
    <div id="3"></div>
```

&emsp;&emsp;insertAfter()　
&emsp;&emsp;将所有匹配元素插入到指定元素的后面 
```
    <p>我想说：</p>
    JQuery代码：$("<b>你好</b>").insertAfter("p")
    结果：<p>我想说：</p><b>你好</b>
```


&emsp;&emsp;insertBefore() 　
&emsp;&emsp;将所有匹配的元素插入到指定的元素的前面 
```
<p>我想说：</p>
JQuery代码：$("<b>你好</b>").insertBefore("p")
结果：<b>你好</b><p>我想说：</p>
```

- - -
##### 作为子元素插入，内部插入
```
    <div id="parent">
        <div id="oldChild"></div>
    </div>
```

&emsp;&emsp;我们想要创建一个新元素并使其成为#parent元素的第一个子元素，就像这样：

```
    <div id="parent">
        <div id="newChild"></div>
        <div id="oldChild"></div>
    </div>
```

```
    $('#parent').prepend('<div id="newChild"></div>');
```

&emsp;&emsp;或创建一个新的元素，使之成为#parent的最后一个子元素：
```
    <div id="parent">
        <div id="oldChild"></div>
        <div id="newChild"></div>
    </div>
```

```
    $('#parent').append('<div id="newChild"></div>');
```


&emsp;&emsp;appendTo()<br/>
&emsp;&emsp;将所有匹配的元素追加到指定的元素中 
```
    <p>我想说：</p>

    JQuery代码：$("<b>你好</b>").appendTo("p")

    结果：
    <p>我想说：<b>你好</b></p>
```

&emsp;&emsp;prependTo()　
&emsp;&emsp;将所有元素前置到指定元素中 
```
    <p>我想说：</p>
    JQuery代码：$("<b>你好</b>").prependTo("p")
    结果：<p><b>你好</b>我想说：</p>
```

- - - 
#### 移动元素
```
    <div id="parent">
        <div id="c1"></div>
        <div id="c2"></div>
        <div id="c3"></div>
    </div>
    <div id="orphan"></div>
```

&emsp;&emsp;移动#orphan作为#parent的最后一个子元素:
```
    $('#parent').append($('#orphan'));
```

&emsp;&emsp;结果:
```
    <div id="parent">
        <div id="c1"></div>
        <div id="c2"></div>
        <div id="c3"></div>
        <div id="orphan"></div>
    </div>
```

&emsp;&emsp;使#orphan作为#parent的第一个子元素:
```
    $('#parent').prepend($('#orphan'));
```

- - -
#### 移除元素
```
    $('#foobar').remove();

    $(“ul li”).remove(“li[title!=a]”)；//将li中title不等于a的<li>元素删除
```

&emsp;&emsp;detach() 　　

&emsp;&emsp;也是从ＤＯＭ中去掉所有匹配元素，但是不会把匹配的元素从jquery对象中删除，因而可以在将来使用这些匹配元素，与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来. 
```
    $("ul li").click(function(){
    alert($(this).html());
    })
    var $li=$("ul li:eq(1)").detach();//删除元素
    $li.appndTo("ul");//重新追加此元素，发现之前的点击事件还能用，如果是remove()则不能再用。
```

&emsp;&emsp;&emsp;&emsp;empty() 
&emsp;&emsp;严格来讲，empty()并不是删除节点，而是清空节点，他能清空元素中的所有后代节点
```
    $("ul li:eq(1)").empty();
    //此时清空了第二个<li>里的内容（注意是元素里），而这个节点符号标记还在，
```

- - - 
#### 复制节点 
&emsp;&emsp;clone() 

&emsp;&emsp;如：点击一个li元素后再复制一个li元素,再将其添加到ul中
```
    $("ul li").click(function(){
    $(this).clone().appendTo("ul");
    })
```

&emsp;&emsp;新复制的节点并不具有任何行为（如之前的单击事件），如果希望复制元素的同时能够复制元素绑定的事件则：
```
    $(this).clone(true).appendTo("body");
```

- - -
#### 替换节点 
&emsp;&emsp;replaceWith() 和 replaceAll作用相同，只是操作相互颠倒 
&emsp;&emsp;如想把`<p title="a">a</p>`换成`<strong>b</strong>`可以如下写代码： 
```
    法一：$("p").replaceWith("<strong>b</strong>"); 
    法二：$("<strong>b</strong>").replaceAll("p");
```
&emsp;&emsp;如果在替换之前已经为元素绑定事件，替换后原先绑定的事件会与被，替换的元素一起消失，需要在新元素上重新绑定事件。


- - - 
#### 包裹节点
&emsp;&emsp;1.wrap()　
&emsp;&emsp;将某个节点用其他标记包裹起来(将所有元素进行单独的包裹) 
&emsp;&emsp;如：
```
    $("strong").wrap("<b></b>"); 
```
&emsp;&emsp;得到的结果为：
```
    <b><strong>b</strong></b>
```

&emsp;&emsp;2.wrapAll() 
&emsp;&emsp;将所有匹配元素用一个元素来包裹。 
```
    <strong>a</strong>
    <strong>b</strong>
```

&emsp;&emsp;如果使用wrap() ，则结果如下：
```
    <b><strong>a</strong></b>
    <b><strong>b</strong></b>
```
如果是 wrapAll() 结果如下：
```
    <b><strong>a</strong>
    <strong>b</strong></b>
```

&emsp;&emsp;如果被包裹的多个元素之间有其他元素，那么其他元素会被放到包裹元素之后

&emsp;&emsp;3.wrappInner()将每一个匹配元素的子内容（包括文本节点）用其他结构化标记包裹起来 
示例：
```
    $("strong").wrapInner("<b></b>");
```
结果如下：
```
    <strong title=""><b>aaa<b></strong>
```

- - - 
#### 属性操作
```
    $('#foo').attr('role');            //获取role属性值
    $('#foo').attr('role', 'button');  //设置role属性为“button”
    $('#foo').removeAttr('role');      //移除role属性
```
&emsp;&emsp;prop() 　
&emsp;&emsp;prop()函数用于设置或返回当前jQuery对象所匹配的元素的属性值。prop()函数的所有”设置属性”操作针对的是当前jQuery对象所匹配的每一个元素；所有”读取属性”的操作只针对第一个匹配的元素。 

&emsp;&emsp;removeProp()函数用于移除在当前jQuery对象所匹配的每一个元素上指定的属性。 
window对象或DOM元素的一些内置属性是不允许删除的，如果试图删除这些属性，将会导致浏览器产生一个错误。jQuery首先会将该属性的值赋为undefined，并忽略掉浏览器生成的任何错误信息。

&emsp;&emsp;一般情况下，你最好使用该函数来删除一些自定义的属性，而不是内置属性。

&emsp;&emsp;请不要使用本函数来删除DOM元素的本地属性checked、selected和disabled。这将彻底删除对应的属性，并且，一旦删除之后，你无法再向该DOM元素重新添加对应的属性。请使用prop()函数将其设为false即可，例如：jQueryObject.prop(“checked”, false)

&emsp;&emsp;`需注意的问题，attr()和prop()的区别。`

- - -
#### 添加&移除CSS样式类
```
    $("p").hasClass("another")        //判断是否含有某个class 有返回true 没有返回false
    $('#foo').addClass('bold');       //增加样式类
    $('#foo').removeClass('bold');    //删除样式类
    $("p").toggleClass("another");    //制样式的重复切换，如果类名存在就删除，类名不在就添加 
```

- - -
#### 添加 & 修改文本内容
```
    $('#foo').html();                 // 返回元素中的html内容
    $('#foo').html('Goodbye!');       // 设置元素中的html内容

    $('#foo').text();                 // 返回元素中的文本内容
    $('#foo').text('Goodbye!');       // 设置元素中的文本内容

    $('#foo').val();                 // 返回元素中的值
    $('#foo').val('Goodbye!');       // 设置元素中的值
```

- - - 
#### 遍历节点
&emsp;&emsp;children() 
&emsp;&emsp;取得匹配元素的子元素集合，此方法只考虑子元素，不考虑其他后代元素。 
```
    <body>
      <p></p>
      <ul>
        <li></li>
        <li></li>
      </ul>
    </body>
```

&emsp;&emsp;jQuery求子元素个数：
```
    var $body=$("body").children;
    alert($body.length);//得到2
```

&emsp;&emsp;next() 
&emsp;&emsp;取得匹配元素后紧邻的同辈元素 
&emsp;&emsp;根据上个html例子
&emsp;&emsp;$("p").next()得到的结果是：
```
    <ul>
      <li></li>
      <li></li>
    </ul>
```

&emsp;&emsp;prev() 
&emsp;&emsp;得到匹配元素前面紧邻的同辈元素
```       
    $("ul").prev();       //得到结果为<p></p>
```

&emsp;&emsp;siblings() 
&emsp;&emsp;取得匹配元素前后所有同辈元素
```
    $("p").siblings()
    //得到结果为：
    <ul>
     <li></li>
     <li></li>
    </ul>
```

&emsp;&emsp;closest() 
&emsp;&emsp;取得最近的匹配元素
&emsp;&emsp;首先检查当前元素是否匹配，如果匹配则直接返回元素本身 ，如果不匹配则向上查找父元素，逐级向上查找匹配选择器的元素，如果什么都没有则返回一个空的jQuery对象（只返回匹配的第一个元素节点，从自身的节点找起）

&emsp;&emsp;给点击目标最近的li元素添加红色：

```
$(document).bind("click",function(e){
$(e.target).closest("li").css("color","red");
})
```

&emsp;&emsp;parent（） 
&emsp;&emsp;获得每个匹配元素的父级元素，从指定类型的直接父节点开始查找，返回一个元素节点

&emsp;&emsp;parents() 
&emsp;&emsp;获得每个匹配元素的祖先元素 返回多个父节点

- - -

#### 增加/更新元素的样式
```
    $('#note').css('color');               //获取字体颜色的值
    $('#note').css('color', 'black');      //设置字体颜色的值
```
&emsp;&emsp;类似的方法还有：
&emsp;&emsp;`height()、width()`

- - -
### jQuery动画
#### 基本动画函数
&emsp;&emsp;基本的动画函数主要分为`show`，`hide`和`toggle`三个，都提供了无参数的版本，表示不适用动画切换元素的显示状态：
```
    $("#divPop").show();
    $("#divPop").hide();
    $("#divPop").toggle();
```
&emsp;&emsp;提供了两个参数的重载,因为回调函数可以省略,所以可以像开篇实例中使用的, 传入一个数值作为唯一参数,则会在参数规定的时间内用动画效果显示/隐藏元素:
```
    $("#divPop").show(200);
    $("#divPop").hide("fast");
    $("#divPop").toggle("slow");
```
&emsp;&emsp;如果传递了 200, 表示图层会在 200 毫秒内通过渐变的形式显示出来. speed 参数可以使用三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000).

&emsp;&emsp;三个函数都可以传入回调函数callback,签名如下:
```
    function callback() {
      this; // dom element
    }
```

&emsp;&emsp;在回调函数中的 this 是执行此函数的 DOM 对象. 会在动画结束时执行。

- - -
##### 使用 toggle 函数
&emsp;&emsp;toggle函数是功能更强大的函数,可以`切换元素的可见状态`.我们经常遇到需要使用toggle的情况.比如希望一段文字第一次单击显示弹出层,第二次单击隐藏弹出层.

&emsp;&emsp;注意: toggle()这个方法在 jQuery1.8 中宣告过时，在 jQuery1.9 中已经移除；jQuery animation也有一个名为toggle的方法。哪一个被调用取决于传递的参数的设置。

- - -
#### 滑动动画函数
&emsp;&emsp;基本动画函数的效果是一个综合了滑动和透明度渐变的函数，jQuery 还单独提供了只有滑动效果的相关函数。

- `slideDown(speed,[callback])`

&emsp;&emsp;通过高度变化（向下增大）来动态地显示所有可匹配的元素，在显示完成后可选地触发一个回调函数。这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来。在jQuery1.3中，上下的padding和 margin也会有动画，效果更流畅。

- `slideUp(speed,[callback])`

&emsp;&emsp;通过高度变化（向上减小）来动态地隐藏所有可匹配的元素，在隐藏完成后可选地触发一个回调函数。

- `slideToggle(speed,[callback])`

&emsp;&emsp;通过高度变化（向上减小）来动态地切换所有可匹配的元素，在切换完成后可选地触发一个回调函数。

&emsp;&emsp;`slideDown`就是`show`的滑动效果版本，

&emsp;&emsp;`slideUp`就是`hide`的滑动效果版本，

&emsp;&emsp;`slideToggle`就是`toggle`的滑动效果版本。

- - -
#### 淡入淡出动画函数
- `fadeIn(speed,[callback])`

&emsp;&emsp;通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画效果完成后触发一个回调函数。

- `fadeOut(speed,[callback])`

&emsp;&emsp;通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画效果完成后触发一个回调函数。

- `fadeOut(speed,opacity,[callback])`

&emsp;&emsp;把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数。

&emsp;&emsp;`fadeIn`和`fadeOut`两个函数对应`show`和`hide`，用于将对象以透明度渐变的效果显示和隐藏：

&emsp;&emsp;透明度渐变没有切换函数.

&emsp;&emsp;需要特别讲解的是fadeTo函数.这个函数能让对象渐变到指定的透明度上. opacity参数取值从 `0-1`, 比如 0.6 表示透明度为 60%.

&emsp;&emsp;和fadeIn与fadeOut不同的是,fadeTo函数只改变对象的`透明度`,即使透明度为 0 对象`仍然占位`.而fadeIn和fadeOut最后一定会改变对象的`display`属性, fadeOut后对象将从页面上消失(不占位),但是fadeTo仅仅是让其透明(占位).

&emsp;&emsp;`fadeTo`函数可以配合`fadeIn`使用.比如默认的情况下,fadeIn最后让对象完全显示。<br/>
&emsp;&emsp;但是如果之前使用过 fadeTo 设置弹出层的透明度, 则可以让其以半透明。<br/>
&emsp;&emsp;核心代码如下:
```
    //设置弹出层的透明度
    $("#divPop").fadeTo(0, 0.66);

    //让弹出层透明显示
    if ($("#divPop").css("display") == "none"){
        $("#divPop").fadeIn(speed);
    }else{
        $("#divPop").fadeOut(speed);
    }
```

&emsp;&emsp;用fadeTo设置了弹出层透明度后,再使用fadeIn会让对象显示并且渐变到fadeTo设置的透明度.

&emsp;&emsp;这里介绍的仅仅是两个函数的特性, 实际应用中并不一定要两者配合使用.

- - -
#### 自定义动画函数
&emsp;&emsp;自定义动画函数 Custom
- `animate( params, [duration], [easing], [callback] )`
- `animate( params, options )`
- `stop( [clearQueue], [gotoEnd] )`

##### 参数说明

&emsp;&emsp;1.`params(可选)`

- 类型:Options

- 说明:一组包含作为动画属性和终值的样式属性和及其值的集合.

- 讲解:通过把元素的样式属性值,从当前值逐渐调整到 params 设置的值而产生动画效果.

&emsp;&emsp;2.`duration(可选)`

- 类型:String,Number

- 说明:三种预定速度之一的字符串("slow","normal",or"fast")或表示动画时长的毫秒数值(如：1000)

- 讲解:动画效果`持续的时间`, 时间越长则变得越慢. 如果省略则不会产生动画.

&emsp;&emsp;3.`easing(可选)`

- 类型:String

- 说明:要使用的擦除效果的名称(需要插件支持).默认 jQuery 提供"linear" 和 "swing".

- 讲解:为了让元素逐渐达到 params 设置的最终效果,我们需要有一个函数来实现渐变, 这类函数就叫做 easing 函数.但是需要这里传递的只是 easing 函数名称, 使用前需要先将 easing 函数注册到 jQuery 上.

&emsp;&emsp;4.`options 参数`

- 类型:Options

- 说明:一组包含动画选项的值的集合。

- 讲解:所支持的属性如下:<br/>
duration: 与上面的 duration 参数相同<br/>
easing: 与上面的 easing 参数相同<br/>
complete :类型为 Function, 在动画完成时执行的函数<br/>
step: Callback<br/>
queue (Boolean): (默认值: true) 设定为 false 将使此动画不进入动画队列 (jQuery 1.2 中新增)<br/>

- - -
### stop( ) 方法
&emsp;&emsp;作用：停止当前正在运行的动画。

&emsp;&emsp;参数：

|参数  |描述  |
|-|-|
|`stopAll` |可选。规定是否停止被选元素的所有加入队列的动画。|
|`goToEnd` |可选。规定是否允许完成当前的动画。<br/>该参数只能在设置了 stopAll 参数时使用。|


- - -
#### 全局控制属性
&emsp;&emsp;最后讲一下和动画相关的属性:
- 名称: jQuery.fx.off
- 返回值: Boolean
- 说明:关闭页面上所有的动画。

&emsp;&emsp;讲解:

&emsp;&emsp;把这个属性设置为 `true` 可以立即关闭所有动画(所有效果会`立即执行完毕`)。有些情况下可能需要这样，比如：<br/>
- 你在配置比较低的电脑上使用 jQuery。<br/>
- 你的一些用户由于动画效果而遇到了可访问性问题<br/>

&emsp;&emsp;当把这个属性设成 false 之后，可以重新开启所有动画。

&emsp;&emsp;比如下面的代码会执行一个禁用的动画:
```
    jQuery.fx.off = true;
    $("#divPop").show(1000);
```

&emsp;&emsp;虽然使用了动画效果的 show 函数, 但是因为关闭了所有动画, 所以 div 会立刻显示出来而没有渐变效果.

- - -
#### jQuery操作DOM
##### 选择器 
基本选择器：
    #id
    .class
    element
    *

层级选择器： 
    空格
    >
    +
    ~

基本过滤选择器：
    :first
    :last
    :eq(index)
    :lt(index)
    :gt(index)
    :odd
    :even

筛选选择器：
    .eq(index)
    .children()
    .parent()
    .siblings()
    .find()

动画：
    show
    hide
    fadeIn
    fadeOut
    fadeTo
    slideDown
    slideUp
    slideToggle
    animate

DOM操作：
    .css()
    addClass(“className”)
    removeClass()
    toggleClass
    .attr()
    removeAttr()
    .val()
    .html(“<p></p>”)
    text()
    node.append(“<p>我是追加的内容</p>”)
    prePend()

- - - 

#### 元素操作
##### 高度和宽度 
```
$(“div”).height();      // 高度
$(“div”).width();           // 宽度
```

.height()方法和.css(“height”)的区别：
  返回值不同，.height()方法返回的是 数字类型(20)，.css(“height”)返回的是字符串类型(20px)，因此.height()方法常用在参与数学计算的时候

##### 坐标值
```
$(“div”).offset();          // 获取或设置坐标值 设置值后变成相对定位
$(“div”).position();        // 获取坐标值 子绝父相 只能读取不能设置
```

- - -
##### 滚动条（滚动事件）
```
$(“div”).scrollTop();       // 相对于滚动条顶部的偏移
$(“div”).scrolllLeft(); // 相对于滚动条左部的偏移
```

案例：两次跟随的广告
案例：防腾讯固定导航栏

- - -
#### jQuery事件
##### 绑定
* click
* mouseenter
* mouseover
* mouseout
* blur
* keyup
* keydown
* keypress
* dbclick
* error
* change

```
// 绑定事件
bind：$node.bind(“click”,function(){});

//绑定两个事件
$node.bind("click mouseenter",function(){});

//两个事件分别触发不同动作
$node.bind(
	{
		"click":function(){}
	},
	{
		"mouseenter":function(){}
	}
);

//传参数到函数里面
$node.bind(“click”,{a:true},function(e){
		alert(e.data.a)
	}
);

// 触发一次
$node.one(“click”,function(){});

//根据某元素下子元素指定标签委托事件（只需给父元素绑定一次事件，无需像bind一样给每个元素各绑定一次）
$node.delegate(“p”,”click”,function(){});

//on  推荐使用，强烈
$node.on(“click”,”p”,function(){});
```

##### 解绑
* unbind （对应bind）
* undelegate (对应delegate)  
* off（对应on）

##### 触发

```
click: 
$("div").click();
----------------
trigger：触发事件，并且触发浏览器默认行为
$("div").trigger("focus")
----------------
triggerHandler：不触发浏览器默认行为,不会产生事件冒泡
$("div").triggerHandler("focus")
```

##### jQuery事件对象介绍

```
event.stopPropagation()； //阻止事件冒泡
event.preventDefault(); //阻止默认行为（a标签的跳转，提交按钮的表单提交等）

event.type       //事件类型
event.which      //鼠标的按键类型，左1，中2，右3
event.keyCode		//键盘编码

```

##### 链式编程
	end()	结束当前调用的链，恢复上一级的调用链
	
##### 隐式迭代
- 默认情况下，会自动迭代执行JQuery选择出来所有dom元素的操作
- 如果获取的是多元素的值，默认返回的是第一个元素的值

##### each函数

```
$.each(array,function(index,element){})
$("li").each(function(){})

```

##### map函数
```
$.map(array,function(element,index){})   //返回一个数组
$("li").map(function(){})
```

##### 全局对象污染冲突
`$、jQuery`

```
$.noConflict();      //让jQuery释放$，让$回归到jQuery之前的对象定义上去
```

##### jQuery.data()
在JQuery对象中储存值
```
$(selector).data("name",123);   //存储值
var t = $(selector).data("name");       //读取值
t.name = "18";		//对象的更改，会直接同步到元素的jQuery对象上去
```

##### jQuery插件
- 全局jQuery函数扩展方法

```
$.log = function(){

}
```

- jQuery对象函数扩展方法

```
$.fn.log = function(){

}
```

##### 延迟加载（懒加载）
根据定位加载

---
## Html5 {#html5}
敬请期待
