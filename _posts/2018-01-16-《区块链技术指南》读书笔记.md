---
layout: post
title: 《区块链技术指南》读书笔记
description: “买不起比特币，看下它跑也行”
category: Programming
tags: []
image: 
    feature: blockchain.jpg
---

&ensp;&ensp;&ensp;&ensp;本文意在进行区块链相关知识的简单介绍，学习与探讨，无权威性，内容大多自行总结自网络内容和《区块链技术指南》，如有错误欢迎指正。针对不同阅读对象，特意将文章内容分为两部分，第一部分为比特币的通俗介绍，不涉及到底层技术原理，算是简单快速的科普。第二部分对《区块链技术指南》的内容进行概括整理，对区块链的技术进行比较深入的研究和探讨。

[1.非专业部分，简介比特币与区块链](#ForChildren)<br/>
[2.关于区块链的技术详解](#Pro)

## 1.非专业部分，比特币与区块链简介 {#ForChildren}
&ensp;&ensp;&ensp;&ensp;比特币是`中本聪（化名）`在2008提出的一种虚拟的`数字货币`，它的本质是一种`分布式的点对点网络系统`。

&ensp;&ensp;&ensp;&ensp;与传统货币相比，比特币完全是虚拟的，其实是连代表比特币的虚拟物品都没有，比特币不是网络里面的某一串代码或者其他明确直接的指代物。

&ensp;&ensp;&ensp;&ensp;比特币是存在于`交易记录`中，比如你有一个比特币，是因为比特币的`账本`中记载着“你有一个比特币”。(其实这也是其他货币的本质，`可信性`，货币首先要被人们所承认，它才有价值，如中国不承认日元，所以日元在中国并无直接的使用价值。在比特币的系统里面就是这个账本，人们承认这个账本，也就承认其中的交易记录，也就承认“你有一个比特币”了。)

&ensp;&ensp;&ensp;&ensp;功能上，比特币与其他货币所具有的功能基本一致，如买卖商品，贷款汇款，兑换成其他货币。对于持有者，拥有的其实是比特币的`控制权的密钥`，用该密钥解锁就可以进行交易活动。

&ensp;&ensp;&ensp;&ensp;最重要的内容来了。

&ensp;&ensp;&ensp;&ensp;`分布式`，意味着`去中心化`，比特币的交易不需要一个管理中心(像使用支付宝的交易过程就需要负责支付宝的公司进行管理)。在比特币这个系统里面，任意双方可以直接进行交易，无需第三方干涉，这种机制可以节省大量的交易活动所产生的成本。

&ensp;&ensp;&ensp;&ensp;每个人都有一个公共账本，这个账本上的内容是`同步`的，即同一时间点每个人的账本上的内容几乎都是相同的（也有不同的情况，后面详细说明）。该账本上记录的就是比特币的`所有的交易记录`，没错，所有全部的交易记录(根据网上的信息，在2015年10月份的时候，该账本的大小约为45GB)，这些数据的结构是`一条链`，链上每一个结就是一个`数据块`，也叫`区块`,每一个区块就是一次交易记录。每个区块中存取的信息有`该块的编号，上一个数据块的编号，该次交易的内容`等等（为方便理解简化描述，实际上复杂很多）。这个就是传说中的 ***区块链技术***，即比特币这个系统所使用的核心技术。
![](http://os738issp.bkt.clouddn.com/bitcoin.png)

&ensp;&ensp;&ensp;&ensp;虽然每个人手里都有一份账本，但不是谁都可以随意修改或增加其中的内容，否则这个系统就全乱套了。区块链中的`信息同步`技术决定了少数人无法自行篡改账本的内容，`密码学`的设计确保货币流通各个环节安全性。

&ensp;&ensp;&ensp;&ensp;当系统中产生一笔新的`交易`时（比如我向系统请求，将我的一个比特币转帐给你），理应就要在这条链上增加一个`新的区块`，而这份工作，只能有一个人来做，这时系统就会向所有人广播，并出一道数学题，谁先做出这道题，就可以获得`写新区块`的工作。当已经有一个人确认获得这份工作时，其他还在争取的人就可以停止了。这道数学题目前没有针对的算法去计算，只能暴力尝试，比如从1开始尝试，不对就尝试2，再到3......所以电脑的计算能力越好，抢到这份工作的概率就越大。

&ensp;&ensp;&ensp;&ensp;凭什么我算死算活就只是为了抢这份记账的工作？因为，每个抢到这份工作的人，系统就会`奖励`你一定的比特币，最开始的时候是50个，这50个比特币就是`凭空产生`的，就好像中央银行刚印出来一张50元的新人民币，那么人民币的总额就多了50元，在这里比特币的总额就多了50个。这个奖励的数额每`4年`就会减半，目前是12.5个。比特币在2140年将达到`2100万`个的总量上限。

&ensp;&ensp;&ensp;&ensp;这个抢工作以获取比特币的过程就是所谓的 ***“挖矿”***。

&ensp;&ensp;&ensp;&ensp;还有一种比较复杂的情况（有需要再详述），会导致账本这条链出现`分支`，即同时有两个甚至更多的同编号的区块想要加入到链中，而且暂时无法确认哪个区块是合法的，比特币这个系统就有一个针对性规则，先任由这几条分支继续发展，谁先增加到`6`个区块就成为合法的链，然后其他的分支就会被舍弃掉。并且，由于挖矿时系统出的那道数学题的难道非常大，将新区块的产生速度控制在了平均每约10分钟一个，所以，比特币的交易不能实时确认，必须等待至少一个小时。

&ensp;&ensp;&ensp;&ensp;非战斗人员看到这里就好了，乖。

---

## 2.关于区块链的技术详解 {#Pro}

&ensp;&ensp;&ensp;&ensp;狭义来讲，区块链是一种按照`时间`顺序将数据区块以顺序相连的方式组合成的一种`链式数据结构`， 并以`密码学`方式保证的不可篡改和不可伪造的`分布式账本`。

&ensp;&ensp;&ensp;&ensp;广义来讲，区块链技术是利用`块链式数据结构`来验证与存储数据、利用`分布式节点共识算法`来生成和更新数据、利用`密码学`的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的`分布式基础架构与计算范式`。

&ensp;&ensp;&ensp;&ensp;2008 年 10 月 31 日，化名 Satoshi Nakamoto （中本聪）的人提出了比特币的设计白皮书（最早见于 metzdowd 邮件列表），并在 2009 年公开了最初的实现代码，第一个比特币是 `2009 年 1 月 3 日 18:15:05` 生成。但真正流行起来还是在 2010 年后的事情。其官方网站是 bitcoin。

---

### 对关键技术的思考
#### 密码学技术

&ensp;&ensp;&ensp;&ensp;需要密码学来解决的问题
- 防止交易记录被篡改
- 证明交易方的身份
- 保护交易双方的隐私


---
#### 分布式共识
&ensp;&ensp;&ensp;&ensp;核心问题：如何解决某个变更在网络中是一致的，是被大家承认的，同时这个信息是被确定的，不可推翻的。

---
#### 处理性能
&ensp;&ensp;&ensp;&ensp;如何提高交易的吞吐量，同时降低交易的确认延迟。

&ensp;&ensp;&ensp;&ensp;实际上，很大程度上取决于单个节点的处理能力。高性能、安全、稳定性、硬件辅助加解密能力，都将是考察节点性能的核心要素。

---
#### 扩展性
&ensp;&ensp;&ensp;&ensp;网络中每个参与维护的核心节点都要保持一份完整的存储，并且进行智能合约的处理。因此，整个网络的总存储和计算能力，取决于单个节点。甚至当网络中节点数过多时，可能会因为一致性的达成过程延迟降低整个网络的性能。尤其在公有网络中，由于大量低质量处理节点的存在问题将更明显。

---
#### 系统安全

- 法律保护
- 潜在漏洞
- 交易记录完全暴露
- 公有的区块链缺乏有效的调整机制
- 对智能合约应用的安全管控

---

#### 数据库和存储系统
&ensp;&ensp;&ensp;&ensp;区块链网络中的块信息需要写到数据库中进行存储。

---

#### 可集成性
&ensp;&ensp;&ensp;&ensp;基于区块链的新业务将与已有的中心化系统共存，其中存在如何共存，如何分工，如何传递彼此的业务交易等问题。

---

#### 其他一些具体的运营问题

---

### 分布式系统核心问题
#### 一致性问题
&ensp;&ensp;&ensp;&ensp;在分布式系统中，一致性(Consistency)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的一致。

- 在实际的计算机集群系统存在的问题：

    - 节点之间的网络通讯不可靠，包括任意延迟和内容故障；
    - 节点的处理可能是错误的，甚至节点自身随时可能宕机；
    - 同步调用会让系统变得不具备可扩展性。

---

- 理想的分布式系统一致性应该满足：

    - 可终止性（Termination）：一致的结果在有限时间内能完成；
    - 共识性(Consensus)：不同节点最终完成决策的结果应该相同；
    - 合法性（Validity）：决策的结果必须是其他进程提出的提案。

---

&ensp;&ensp;&ensp;&ensp;越强的一致性要求往往意味着越弱的性能，强一致性(Strong Consistency)主要包括：

- 顺序一致性 (Sequential Consistency)
    - 保证所有进程看到的全局执行顺序一致，并且每个进程看自身的执行跟实际发生顺序一致。

- 线性一致性（Linearizability Consistency）
    - 在顺序一致性的前提下加强了进程间的操作排序，形成唯一的全局顺序

##### 弱一致性(Weak COnsistency)
&ensp;&ensp;&ensp;&ensp;强一致的系统比较难实现，很多时候在需求没有那么强大额时候适当放宽一致性要求，降低系统实现的难度，如在一定约束下实现最终一致性（Eventual Consistency）（总会存在一个时刻，而不是立刻），对于大部分Web系统来说已经足够了。


---

#### 共识算法
&ensp;&ensp;&ensp;&ensp;共识算法解决的是对某个提案（Proposal），大家达成一致意见的过程。

#####问题挑战
&ensp;&ensp;&ensp;&ensp;若分布式系统中每个节点都能保证以十分强大的性能（瞬间响应、高吞吐）无故障的运行，简单通过多播过程投票即可实现共识过程。但现实中响应请求往往存在时延、网络中断、节点故障、存在试图破坏系统的恶意节点等。

- 故障（不响应）的情况称为“非拜占庭错误”
- 恶意响应的情况称为“拜占庭错误”（对应节点为拜占庭节点）

##### 常见算法
- 针对非拜占庭错误的情况，一般包括`Paxos、Raft`及其变种。
- 针对能容忍拜占庭错误的情况，一般包括PBFT系列、PoW系列算法等。

##### 理论界限
&ensp;&ensp;&ensp;&ensp;一般情况下，分布式系统的共识问题无解。

&ensp;&ensp;&ensp;&ensp;在节点之间的通信网络自身不可靠的情况下，无法确保实现共识。一个设计得当的网络可以在大概率上实现可靠的通信。

&ensp;&ensp;&ensp;&ensp;在网络通信可靠的情况下，一个可扩展的分布式系统的共识问题的下限是无解。

&ensp;&ensp;&ensp;&ensp;该结论被称为`“FLP不可能性”`原理。

---

#### FLP不可能性原理
- FLP不可能性原理：在网络可靠，存在节点失效（即便只要一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。

---

#### CAP原理
&ensp;&ensp;&ensp;&ensp;分布式系统领域的重要原理

##### 定义
&ensp;&ensp;&ensp;&ensp;分布式系统不可能同时确保`一致性（Consistency）`、`可用性（Availablity）`和`分区容忍性（Partition）`,设计中往往需要`弱化`对某个特性的保证。

- 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，这里指的是强一致性；
- 可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求；
- 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。

##### 弱化一致性
&ensp;&ensp;&ensp;&ensp;对结果一致性不敏感的应用，可以允许在新版本上线后过一段时间才更新成功，期间不保证一致性。

##### 弱化可用性
&ensp;&ensp;&ensp;&ensp;对结果一致性很敏感的应用，例如银行取款机，当系统故障时会拒绝服务。Paxos、Raft等算法，主要处理这种情况。

##### 弱化分区容忍性
&ensp;&ensp;&ensp;&ensp;现实中，网络分区出现概率减小，但较难避免。实践中网络通过双通道等机制增强可靠性没达到高稳定的网络通信。

---

#### ACID原则
&ensp;&ensp;&ensp;&ensp;ACID原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价。

- Atomicity(原子性)： 每次操作都是原子的，要么成功，要么不执行；

- Consistency(一致性)：数据库的状态是一致的，无中间状态；
- Isolation(隔离性)：各种操作彼此互相不影响；
- Durability(持久性)：状态的改变是持久的，不会失效

&ensp;&ensp;&ensp;&ensp;与之相对的原则是`BASE原则（Basic Availiability,Soft state,Eventually Consistency）`

---

#### Paxos与Raft

##### Paxos 
&ensp;&ensp;&ensp;&ensp;Paxos问题是指分布式的系统中存在故障，但不存在恶意节点场景（即消息可能丢失或重复，但无错误）下的共识达成问题。

&ensp;&ensp;&ensp;&ensp;Paxos共识算法于1990年由Leslie Lamport提出，在工程角度实现了一种最大化保障分布式系统一致性（存在极小的概率无法实现一致）的机制。

&ensp;&ensp;&ensp;&ensp;Leslie Lamport因此获得2013年度图灵奖。

&ensp;&ensp;&ensp;&ensp;Paxos是第一个被证明的共识算法，原理基于“两阶段提交”并进行扩展。

&ensp;&ensp;&ensp;&ensp;算法将节点分为三点类型：

- proposer:提出一个提案，等待大家批准为结案。一般为客户端；
- acceptor:负责对结案进行投票。一般为服务端；
- learner:被告知结案结果,并与之统一，不参与投票过程，可能为客户端或服务端。

&ensp;&ensp;&ensp;&ensp;并且需要满足safety和liveness两方面的约束要求：

- safety：保证协议结果是对的，无歧义的，不会出现错误情况。
   * 决议（value）只有在被proposers提出的proposal才能被最终批准。
   * 在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；
- liveness:保证决议过程能在有限时间内完成。
   * 决议总会产生，并且learner能获得被批准（chosen）的决议。

&ensp;&ensp;&ensp;&ensp;基本过程：

- 1.Proposer提出提案，争取大多数acceptor的支持；
- 2.超过一半支持时，则发送结案结果给所有人进行确认；

&ensp;&ensp;&ensp;&ensp;当proposer在此过程中出现故障，可以通过超时机制来解决。

&ensp;&ensp;&ensp;&ensp;概率极小的情况下，每次新的一轮提案的proposer都刚好故障，系统则永远无法达成一致。

&ensp;&ensp;&ensp;&ensp;Paxos能保证超过1/2的正常节点存在时，系统能达成共识。

- 单个提案者+多个接收者

&ensp;&ensp;&ensp;&ensp;一致性肯定能达成（只有一个方案）；当提案者故障时系统无法工作；

- 多个提案者+单个接收者
&ensp;&ensp;&ensp;&ensp;容易达成共识，选择第一个提案，拒绝后续提案。同样容易发生单点故障。

- 多个提案者+多个接收者

  * 1.同一时间片段内只有一个提案者，需要保障提案者的正确产生。由于分布式系统工作量大，该过程需尽量高效，设计难度大；
  
  * 2.同一时间片段内多个提案者，同一节点可能受到多份提案。给提案带上不同编号，节点根据编号判断选择接受提案。
   
##### 两阶段的提交
* 准备阶段：
    - 提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多数接受者的支持。  
    - 接受者时刻保留收到过提案的最大编号和接受的最大提案。如果收到的提案号比目前保留的最大提案号还大，则返回自己已接受的提案值（如果还没接受过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接受小于最大提案号的提案。 
* 提交阶段：
    - 提案者如果收到大多数的回复（表示大部分人听到它的请求），则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功，则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没收到足够多的回复，则需要再次发出请求。
    - 接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。
* 一旦多数接受了共同的提案值，则形成决议，成为最终确认的提案。
   
---

##### Raft
&ensp;&ensp;&ensp;&ensp;Paxos算法的一种简化实现。

&ensp;&ensp;&ensp;&ensp;三种角色：leader,candidate和follower

&ensp;&ensp;&ensp;&ensp;基本流程：

- Leader选举：每个candidate随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为leader;
- 同步log（各种事件的发生记录）：leader会找到系统中log最新的记录，并强制所有的follower来刷新到这个记录；

---

#### 拜占庭问题与算法
&ensp;&ensp;&ensp;&ensp;拜占庭问题讨论的是允许少数节点的消息可能被伪造的场景下的一致性达成问题，讨论的是最坏情况下的保障。

##### 中国将军问题
- 两个将军要通过信使来达成进攻还是撤退的约定，但信使可能迷路或被敌军阻拦（消息丢失或伪造），如何达成一致。根据FLP不可能原理，这个问题无解。

##### 拜占庭问题
&ensp;&ensp;&ensp;&ensp;又称拜占庭将军问题，是一个用来解释一致性问题的虚构模型。

&ensp;&ensp;&ensp;&ensp;拜占庭是古代东罗马帝国的首都，地域辽阔，守卫边疆的多个将军（系统中的多个节点）需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒（系统中节点出错），这些叛徒将努力向不同的将军发送不同的消息，试图干扰一致性的达成。

- 假如总共有N个将军（节点总数为N）                                                                               
- 叛变将军数为F(系统中有F个节点出错)
- 当（？）时，问题才有解，即Byzantine Fault Tolerant(BFT)算法

先讨论提案人不是叛徒的情况

例如，N = 3,F = 1，将军A为提案人，将军C为叛徒：
![](http://os738issp.bkt.clouddn.com/2018/1/17-上午11:37:42.png)
将军A提出信息1，分别发给B与C，
B不是叛变者，所以B也会同样把信息1发给C
C是叛徒，为了扰乱信息，发了一个相反的信息0给B

对于作为合作者的B与C来说，系统中会有(N - F)份即 3 - 1 = 2份确定的消息（因为作为提案者的将军A不是叛变者，所以A向B跟C发出的消息肯定是一致的，视为一份消息；B也不是叛变者，所以B向C发出的也是确定的消息。），另有F份即1份不确定的消息（因为C为叛变者，为干扰系统可能会发出相反的消息0，也有可能发出正确的消息1，不能够确定），若C发出相反的消息0，则在B的视角看来，A发过来一个1，C发来一个0，在他自己不确定提案者是否为叛变者的情况下，无法判断哪个为真，也就无法判断哪个为叛变者（但由于收到两个不同的消息，至少已经确认其中有一个是叛变者），所以整个系统无法达成一致。 

---

再看一种情况，N = 4,F = 1,将军A为提案人，将军C为叛徒：
![](http://os738issp.bkt.clouddn.com/1111.png)
将军A提出信息1，分别发给B，C与D，系统中会有(N - F)份即 4 - 1 = 3份确定的消息(A发出的1，B发出的1，D发出的1)，F份即1份不确定的消息（C发出的），但是B收到两个1，一个0，会承认正确信息为1，D也类似，那么系统中有三个人是可以统一消息1的，系统可以达成一致。

在提案人不是叛变者的情况下，假设叛变者会尽量干扰达成一致的情况下，需要 N - F > F,即 N > 2F 的情况下才能达成一致。

---

然后来看提案者是叛变者的情况：
![](http://os738issp.bkt.clouddn.com/2.png)
为了扰乱系统，A会分别向B跟C发送不同的消息1与0
不确定的消息为A发出的，即F = 1
确定的为B和C发出的，N - F = 3 - 1 = 2
B和C不是叛变者，所以都会向对方传达自己收到的信息
结果B和C都收到一个1和一个0，在自己无法确定提案者是否为叛变者的情况下，B和C也无法确认信息的真假，系统也无法达成共识。

N = 4 的时候,提案者A为叛变者：
![](http://os738issp.bkt.clouddn.com/3.png)

但B，C，D都是收到两个0一个1，承认信息0，3个人能达成共识，已经超过系统总节点数的一半，则系统可以达成共识。

设想f个叛变者和g个忠诚者，叛变者故意使坏，可以给出错误的结果，也可以不响应。某个时候f个叛变者都不响应，则g个忠诚者取多数即能达到正确结果。当f个叛变者都给出一个恶意的提案，并且g个忠诚者中有f个离线时，剩下的 g - f 个忠诚者无法分辨是否混入了叛变者，仍然要确保多数能到到正确结果，因此，g - f > f,即 g > 2f,所以系统整体规模要大于3f。

能确保达成一致的拜占庭系统节点数至少为4，允许出现1个坏的节点。

---
#### Byzantine Fault Tolenrant算法
面向拜占庭问题的容错算法，解决的是网络通信可靠，但节点可能故障 情况下的一致性达成。

最早有Castro和Liskov在1999年提出的Practical Byzantine Fault Tolenrant（PBFT）是第一个得到广泛应用的BFT算法。只要系统中有2/3的节点是正常工作的，则可以保证一致性。
PBFT算法包括三个阶段来达成共识：Pre-Prepare、Prepare和Commit。

关于这个算法，目前个人估计要一篇论文级的文章才讲得清楚，暂时惹不起，有兴趣可以自己先查阅专门的资料。

---

#### 新的解决思路
拜占庭问题的难点在于任何时候系统中都可能存在多个提案（提案成本低），并且要完成最终的一致性确认过程十分困难，容易受干扰。但是一旦确认，即为最终确认。
比特币在设计时提出创新的PoW（Proof of Work）（就是比特币里面的挖矿了）算法思路：

- 限制一段时间内整个网络中出现提案的个数（提价提案成本）
- 另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。系统的最终确认是概率意义上的存在。这样，即便有人试图恶意破坏，也会付出很大地经济代价（付出超过系统一半的算力）。

后来的各种PoX系列算法，也是沿着这个思路进行改进，采用经济上的惩罚来制约破坏者。

---

#### 可靠性指标

---

#### 小结

---

### 密码学与安全技术
#### Hash算法与摘要

---

#### 加解密算法

---

#### 数字签名

---

#### 数字证书

---

#### PKI体系

---

#### Merkle树

---

#### 同态加密

---

#### 其他问题

---

#### 小结

---

### 比特币项目
####简介

---

#### 原理和设计

---

#### 挖矿

---

#### 工具

---

#### 共识机制

---

#### 闪电网络

---

#### 侧链

---

#### 小结

---






