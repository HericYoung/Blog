---
layout: post
title: Python学习笔记
description: Life is short,you need Python
category: Programming
tags: []
image: 
    feature: python.png
---
该笔记整理自廖雪峰的Python3文字教程，要查看详细教程请点击原文链接：
[廖雪峰的Python教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)

目录(点击可直接跳转)：

[一、数据结构](#DataType)<br/>
[二、变量](#Variable)<br/>
[三、常量](#Costant)<br/>
[四、数学运算](#ArithmeticalOperation
)<br/>
[五、编码](#Code)<br/>
[六、Python字符串](#String)<br/>
[七、其他数据类型](#OtherDataType)<br/>
[八、条件判断和循环](#ConditionJudgmentAndCycle)<br/>
[九、函数](#Function)<br/>
[十、高级特性](#AdvancedCharacteristics)<br/>
[十一、函数式编程](#FunctionalProgramming)<br/>
[十二、模块](#Module)<br/>
[十三、面向对象编程](#ObjectOrientedProgramming)<br/>
[十四、错误、调试和测试](#Error)<br/>
[十五、IO编程](IOOperation)<br/>


# 一、数据结构 {#DataType}
## 1. 整数
```
a = 1
b = 2
```

## 2. 浮点数
```
a = 1.23
```

## 3. 字符串
```
a = "Python"
b = 'Python'
c = r"Python"    #raw string，取消转义字符

d = '''Life
is
short
,
You
need
Python'''   #多行文本，保留完整格式，包括缩进
		
```

## 4. 布尔值
```
a = True
b = False
```

## 5. 空值
```
a = None    #None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
```

---


# 二、变量 {#Variable}
```
#赋值过程

a = 'ABC'	#创建字符串'ABC'和变量a，把a指向'ABC'
b = a		#创建变量b，把b同样指向上一行中创建的字符串'ABC'
a = 'XYZ'	#创建字符串'XYZ',把a改为指向字符串'XYZ'
print(b)	#输出"ABC"

```

---
1.
`a='ABC'`

![](http://os738issp.bkt.clouddn.com/2017/12/29-下午3:56:50.png)


2.
`b = a	`
![](http://os738issp.bkt.clouddn.com/2017/12/29-下午3:58:35.png)

3.
`a='XYZ'`

![](http://os738issp.bkt.clouddn.com/2017/12/29-下午4:00:04.png)

---

# 三、常量 {#Costant}
&ensp;&ensp;&ensp;&ensp;常量就是不能改变的变量，Python中，通常用`全部大写`的变量名表示常量：  

```
PI = 3.14159265359  
```

&ensp;&ensp;&ensp;&ensp;但事实上PI仍然是一个`变量`，
Python根本没有任何机制保证PI不会被改变，
所以，用全部大写的变量名表示常量只是一个`习惯`上的用法，
如果你一定要改变变量PI的值，也没人能拦住你。

---

# 四、数学运算 {#ArithmeticalOperation}
&ensp;&ensp;&ensp;&ensp;加减乘等比较简单，与其他编程语言的用法基本一致，这里不讲。

&ensp;&ensp;&ensp;&ensp;下面主要讲下Python`除法`

```
#整数除法是精确的
>>> 10 / 3
3.3333333333333335

#无论被除数与除数类型为如何，结果都为浮点数
>>> 9 / 3
3.0

# // 表示整数的地板除，即输出结果为原本正确运算答案的整数部分
# 就相当于是Java，PHP等部分编程语言的整数除法
>>> 10 // 3
3
```

---

# 五、字符编码 {#Code}
&ensp;&ensp;&ensp;&ensp;在`计算机内存`中，统一使用`Unicode`编码，当需要`保存到硬盘`或者需要`传输`的时候，就转换为`UTF-8`编码。

&ensp;&ensp;&ensp;&ensp;用`记事本`编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：
![](http://os738issp.bkt.clouddn.com/code1.png)

---

&ensp;&ensp;&ensp;&ensp;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：
![](http://os738issp.bkt.clouddn.com/code2.png)

---

# 六、Python的字符串 {#String}
&ensp;&ensp;&ensp;&ensp;在Python3中，`字符串`是以`Unicode`编码的，所以，Python的字符串支持多语言。  

&ensp;&ensp;&ensp;&ensp;对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符：

```
>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'

#如果知道字符的整数编码，还可以用十六进制这么写str：

>>> '\u4e2d\u6587'
'中文'
```

&ensp;&ensp;&ensp;&ensp;字符串类型在内存中以`Unicode`表示，一个`字符`对应若干个`字节`。如果要在网络上传输，或者保存到磁盘上，就需要把`str`变为以`字节`为单位的`bytes`。

&ensp;&ensp;&ensp;&ensp;Python对bytes类型的数据用带b前缀的单引号或双引号表示：

```
x = b'ABC'
```

&ensp;&ensp;&ensp;&ensp;要注意区分`'ABC'`和`b'ABC'`，前者是`str`，后者虽然内容显示得和前者一样，但bytes的每个字符都`只占用一个字节`（str因为使用的是Unicode编码，每个字符使用占用`两`个字节，非常偏僻的字符占用`四`个字节）。

以`Unicode`表示的`str`通过`encode()`方法可以编码为指定的`bytes`，例如：

```
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
```


- `纯英文`的`str`可以用`ASCII`编码为`bytes`，内容是一样的，`含有中文`的`str`可以用`UTF-8`编码为`bytes`。含有中文的str无法用ASCII编码，因为`中文编码`的范围超过了`ASCII`编码的范围，Python会报错。
- 在bytes中，无法显示为`ASCII`字符的字节，用`\x##`显示。

---

&ensp;&ensp;&ensp;&ensp;反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用`decode()`方法：

```
>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
```
---
&ensp;&ensp;&ensp;&ensp;要计算str包含多少个`字符`，可以用`len()`函数：

```
>>> len('ABC')
3
>>> len('中文')
2
```
---
`len()`函数计算的是`str的字符数`，如果换成bytes，len()函数就计算`字节数`：

```
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
```
- 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。
- 为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

---
&ensp;&ensp;&ensp;&ensp;由于Python源代码也是一个`文本文件`，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为`UTF-8编码`。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```
&ensp;&ensp;&ensp;&ensp;第一行注释是为了告诉`Linux/OS X`系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

&ensp;&ensp;&ensp;&ensp;第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

&ensp;&ensp;&ensp;&ensp;申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用`UTF-8 without BOM`编码；

&ensp;&ensp;&ensp;&ensp;如果.py文件本身使用UTF-8编码，并且也申明了`# -- coding: utf-8 --`，打开命令提示符测试就可以正常显示中文。

---
### 字符串的格式化
&ensp;&ensp;&ensp;&ensp;在Python中，采用的格式化方式和C语言是一致的，用`%`实现，举例如下：

```
>>> 'Hello, %s' % 'world'
'Hello, world'

>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
```

&ensp;&ensp;&ensp;&ensp;`%s`表示用`字符串`替换，`%d`表示用`整数`替换，有几个`%?`占位符，后面就跟几个`变量或者值`，`顺序`要对应好。如果只有一个`%?`，括号可以省略。

代码|类型
-|-
%d|整数
%f|浮点数
%s|字符串
%x|十六进制整数

&ensp;&ensp;&ensp;&ensp;其中，`格式化整数`和`浮点数`还可以指定`是否补0`和整数与小数的`位数`：

```
>>> '%2d-%02d' % (3, 1)
' 3-01'

>>> '%.2f' % 3.1415926
'3.14'

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：

>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
```
&ensp;&ensp;&ensp;&ensp;当字符串里面的`%`是一个`普通字符`时，用`%%`来转义，表示字符`%`：

```
>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'
```

---

# 七、其他数据类型 {#OtherDataType}
## 1. list(列表)
&ensp;&ensp;&ensp;&ensp;list是一种`有序`的`集合`，可以随时添加和删除其中的元素。

&ensp;&ensp;&ensp;&ensp;比如，列出班里所有同学的名字，就可以用一个list表示：

```
>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']
```

&ensp;&ensp;&ensp;&ensp;变量classmates就是一个list。用`len()`函数可以获得list元素的个数：

```
>>> len(classmates)
3
```

&ensp;&ensp;&ensp;&ensp;用索引来访问list中每一个位置的元素，记得索引是从`0`开始的：

```
>>> classmates[0]
'Michael'

>>> classmates[1]
'Bob'

>>> classmates[2]
'Tracy'

>>> classmates[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

&ensp;&ensp;&ensp;&ensp;当索引超出了范围时，Python会报一个`IndexError错误`，所以，要确保索引不要越界，记得最后一个元素的索引是`len(classmates) - 1`。

&ensp;&ensp;&ensp;&ensp;如果要取最后一个元素，除了计算索引位置外，还可以用`-1`做索引，直接获取最后一个元素：

```
>>> classmates[-1]
'Tracy'
以此类推，可以获取倒数第2个、倒数第3个：

>>> classmates[-2]
'Bob'

>>> classmates[-3]
'Michael'

>>> classmates[-4]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

&ensp;&ensp;&ensp;&ensp;list是一个`可变`的有序表，所以，可以往list中追加元素到末尾：

```
>>> classmates.append('Adam')

>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam']
```

&ensp;&ensp;&ensp;&ensp;也可以使用`insert(index,value)`把元素插入到指定的位置，比如索引号为1的位置：

```
>>> classmates.insert(1, 'Jack')


>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
```

&ensp;&ensp;&ensp;&ensp;要删除list末尾的元素，用`pop()`方法：

```
>>> classmates.pop()
'Adam'

>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy']
```

&ensp;&ensp;&ensp;&ensp;要删除指定位置的元素，用`pop(i)`方法，其中i是索引位置：

```
>>> classmates.pop(1)
'Jack'

>>> classmates
['Michael', 'Bob', 'Tracy']
```

&ensp;&ensp;&ensp;&ensp;要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：

```
>>> classmates[1] = 'Sarah'

>>> classmates
['Michael', 'Sarah', 'Tracy']
```

&ensp;&ensp;&ensp;&ensp;list里面的元素的数据类型也可以不同，比如：

```
>>> L = ['Apple', 123, True]
list元素也可以是另一个list，比如：

>>> s = ['python', 'java', ['asp', 'php'], 'scheme']

>>> len(s)
4
```

&ensp;&ensp;&ensp;&ensp;要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：

```
>>> p = ['asp', 'php']

>>> s = ['python', 'java', p, 'scheme']
```

&ensp;&ensp;&ensp;&ensp;要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组。
如果一个list中一个元素也没有，就是一个空的list，它的长度为0：

```
>>> L = []

>>> len(L)
0
```
---

## 2 tuple(元祖)
&ensp;&ensp;&ensp;&ensp;tuple与list类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：

```
>>> classmates = ('Michael', 'Bob', 'Tracy')
```

&ensp;&ensp;&ensp;&ensp;现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常访问其中元素，但不能赋值。

&ensp;&ensp;&ensp;&ensp;不可变的tuple的意义在于使代码更安全。

&ensp;&ensp;&ensp;&ensp;`如果可能，应尽量用tuple代替list。`

&ensp;&ensp;&ensp;&ensp;在定义一个tuple时，tuple的元素就必须被确定下来，比如：

```
>>> t = (1, 2)
>>> t
(1, 2)
```

&ensp;&ensp;&ensp;&ensp;如果要定义一个`空的tuple`，可以写成`()`：

```
>>> t = ()
>>> t
()
```

&ensp;&ensp;&ensp;&ensp;但是，要定义一个只有1个元素的tuple，如果你这么定义：

```
>>> t = (1)
>>> t
1
```

&ensp;&ensp;&ensp;&ensp;定义的不是tuple，是`1`这个数字，这是因为`括号()既可以表示tuple，又可以表示数学公式中的小括号`，这就产生了歧义。

&ensp;&ensp;&ensp;&ensp;因此，Python规定，这种情况下，`按小括号进行计算`，计算结果自然是1。

&ensp;&ensp;&ensp;&ensp;所以，只有1个元素的tuple定义时必须加一个`逗号`,，来消除歧义：

```
>>> t = (1,)
>>> t
(1,)
```

&ensp;&ensp;&ensp;&ensp;Python在显示只有1个元素的tuple时，也会加一个逗号，以消除歧义。

&ensp;&ensp;&ensp;&ensp;最后来看一个`“可变的”`tuple：

```
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
```

&ensp;&ensp;&ensp;&ensp;这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。

&ensp;&ensp;&ensp;&ensp;表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，`指向永远不变`。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，`但指向的这个list本身是可变的`。

&ensp;&ensp;&ensp;&ensp;理解了“指向不变”后，要创建一个内容也不变的tuple,就必须保证tuple的`每一个元素本身也不能变`。

---

## 3. dict(字典)
&ensp;&ensp;&ensp;&ensp;dict全称dictionary，在其他语言中也称为map，使用`键-值（key-value）`存储，具有极快的查找速度。

```
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}

>>> d['Michael']
95
```

&ensp;&ensp;&ensp;&ensp;把数据放入dict的方法，除了初始化时指定外，还可以通过`key`放入：

```
>>> d['Adam'] = 67

>>> d['Adam']
67
```

&ensp;&ensp;&ensp;&ensp;由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

```
>>> d['Jack'] = 90

>>> d['Jack']
90

>>> d['Jack'] = 88

>>> d['Jack']
88
```

&ensp;&ensp;&ensp;&ensp;如果key不存在，dict就会报错：

```
>>> d['Thomas']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Thomas'
```

&ensp;&ensp;&ensp;&ensp;要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在：

```
>>> 'Thomas' in d
False
```

&ensp;&ensp;&ensp;&ensp;二是通过dict提供的`get`方法，如果key不存在，可以返回`None`，或者`自己指定的value`：

```
>>> d.get('Thomas')
>>> d.get('Thomas', -1)
-1
```

&ensp;&ensp;&ensp;&ensp;注意：`返回None的时候Python的交互式命令行不显示结果`。

&ensp;&ensp;&ensp;&ensp;要删除一个key，用`pop(key)`方法，`对应的value也会从dict中删除`：

```
>>> d.pop('Bob')
75

>>> d
{'Michael': 95, 'Tracy': 85}
```

&ensp;&ensp;&ensp;&ensp;`dict内部存放的顺序和key放入的顺序是没有关系的。`

&ensp;&ensp;&ensp;&ensp;和list比较，dict有以下几个特点：
* 查找和插入的速度极快，不会随着key的增加而变慢；
* 需要占用大量的内存，内存浪费多。
而list相反：
* 查找和插入的时间随着元素的增加而增加；
* 占用空间小，浪费内存很少。

&ensp;&ensp;&ensp;&ensp;所以，dict是用空间来换取时间的一种方法。

&ensp;&ensp;&ensp;&ensp;正确使用dict非常重要，需要牢记的第一条就是`dict的key必须是不可变对象。`

&ensp;&ensp;&ensp;&ensp;这是因为dict根据key来计算value的存储位置。这个通过key计算位置的算法称为哈希算法（Hash）。

&ensp;&ensp;&ensp;&ensp;要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，可用作key。而list是可变的，就不能作为key：

```
>>> key = [1, 2, 3]
>>> d[key] = 'a list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

---

## 4. set(集合)
&ensp;&ensp;&ensp;&ensp;set和dict类似，也是一组key的集合，但不存储value。在set中，没有重复的key。

&ensp;&ensp;&ensp;&ensp;要创建一个set，需要提供一个`list`作为输入集合：

```
>>> s = set([1, 2, 3])

>>> s
{1, 2, 3}
```

&ensp;&ensp;&ensp;&ensp;通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：

```
>>> s.add(4)

>>> s
{1, 2, 3, 4}

>>> s.add(4)

>>> s
{1, 2, 3, 4}
```
&ensp;&ensp;&ensp;&ensp;通过`remove(key)`方法可以删除元素：

```
>>> s.remove(4)
>>> s
{1, 2, 3}
```

&ensp;&ensp;&ensp;&ensp;set可以看成数学意义上的`无序和无重复元素的集合`，因此，两个set可以做`数学意义上的交集、并集`等操作：

```
>>> s1 = set([1, 2, 3])

>>> s2 = set([2, 3, 4])

>>> s1 & s2
{2, 3}

>>> s1 | s2
{1, 2, 3, 4}
```

&ensp;&ensp;&ensp;&ensp;set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。

---

# 八、条件判断和循环{#ConditionJudgmentAndCycle}
## 1.条件判断
```
age = 3
if conditionA:
    #operation A
elif conditionB:
    #operationB
else:
    #other operation
```

&ensp;&ensp;&ensp;&ensp;if语句从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else。

&ensp;&ensp;&ensp;&ensp;if后面可以跟条件表达式（如a >= 1)或变量，只要变量是非零数值、非空字符串、非空list等，就判断为True，否则为False。

&ensp;&ensp;&ensp;&ensp;另外，Python允许类如'1 < a < 7'的表达式。（在其他某些编程语言中需要写成`if(a > 1 && a < 7)`的形式）

---

## 2.循环
Python的循环有两种：

- for...in循环
&ensp;&ensp;&ensp;&ensp;依次把list或tuple中的每个元素迭代出来

```
names = ['Michael', 'Bob', 'Tracy']

for name in names:    
    print(name)
```

&ensp;&ensp;&ensp;&ensp;Python提供一个`range()`函数，可以生成一个`整数序列`，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：

```
>>> list(range(5))
[0, 1, 2, 3, 4]
```

---

- while循环
&ensp;&ensp;&ensp;&ensp;只要条件满足，就不断循环，条件不满足时退出循环。

&ensp;&ensp;&ensp;&ensp;计算100以内所有奇数之和，可以用while循环实现：

```
sum = 0
n = 99
while n > 0:
    sum = sum + n
    n = n - 2
print(sum)
```
---

- break
&ensp;&ensp;&ensp;&ensp;可以提前退出循环。

- continue
&ensp;&ensp;&ensp;&ensp;跳过当前的这次循环，直接开始下一次循环。

---

# 九、函数 {#Funcrion}
## 1.函数定义
&ensp;&ensp;&ensp;&ensp;在Python中，定义一个函数要使用`def`语句，依次写出`函数名、括号、括号中的参数和冒号:`，然后，在`缩进块`中编写函数体，函数的返回值用`return`语句返回。

```
def function_name(parameter):
    #operation
```

&ensp;&ensp;&ensp;&ensp;函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。

&ensp;&ensp;&ensp;&ensp;如果没有return语句，函数执行完毕后也会返回结果，只是结果为`None`。

&ensp;&ensp;&ensp;&ensp;`return None`可以简写为`return`。

&ensp;&ensp;&ensp;&ensp;在Python交互环境中定义函数时，注意Python会出现`...`的提示。函数定义结束后需要`按两次回车`重新回到`>>>`提示符下。

&ensp;&ensp;&ensp;&ensp;如果已经把`myFun()`的函数定义保存在`funTest.py`文件中，那么，可以在该文件的当前目录下启动Python解释器，用`from abstest import myFun`来导入myFun()函数，注意`funTest`是文件名（不含.py扩展名）。

---

## 2.空函数
&ensp;&ensp;&ensp;&ensp;使用pass语句：

```
def nop():
    pass
```

&ensp;&ensp;&ensp;&ensp;函数体中若什么都不写，代码运行就会有语法错误，所以就算什么都不做至少也要留一个`pass`。

&ensp;&ensp;&ensp;&ensp;条件语句和循环语句中也一样，如：

```
if age >= 18:
    pass
```

---

## 3. 参数检查
&ensp;&ensp;&ensp;&ensp;`参数个数`不对，Python解释器会抛出`TypeError`：

```
>>> my_abs(1, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: my_abs() takes 1 positional argument but 2 were given
```
&ensp;&ensp;&ensp;&ensp;`参数类型`不对，Python解释器无法检查出来。

```
>>> my_abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in my_abs
TypeError: unorderable types: str() >= int()

>>> abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'str'
```

&ensp;&ensp;&ensp;&ensp;当传入不恰当的参数时，`内置函数abs`会检查出参数错误，而`自定义`的my_abs没有参数检查，会导致出错，出错信息和abs不一样。

&ensp;&ensp;&ensp;&ensp;可完善自定义函数定义，对`参数类型`做检查，只允许整数和浮点数类型的参数。数据类型检查可以用`内置函数isinstance()`实现：

```
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x >= 0:
        return x
    else:
        return -x
```

---

## 4.返回多个值
```
import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
    
>>> x, y = move(100, 100, 60, math.pi / 6)
>>> print(x, y)
151.96152422706632 70.0
```

&ensp;&ensp;&ensp;&ensp;其实该函数的返回值是一个`tuple`。在语法上，返回一个tuple可以`省略括号`，而`多个变量可以同时接收一个tuple，按位置赋给对应的值`，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

---

## 5.函数的参数

### 1.位置参数
&ensp;&ensp;&ensp;&ensp;调用函数时，传入的多个参数按照定义函数时的参数位置顺序依次赋值。

---

### 2.默认参数

```
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```
&ensp;&ensp;&ensp;&ensp;注意事项：

* 一是必选参数在前，默认参数在后，否则解释器会报错；

* 二是如何设置默认参数。

&ensp;&ensp;&ensp;&ensp;使用默认参数最大的好处是能降低调用函数的难度。无论是简单调用还是复杂调用，函数只需要定义一个。

&ensp;&ensp;&ensp;&ensp;有多个默认参数时，调用的时候，既可以按顺序提供默认参数，也可以不按顺序提供部分默认参数，只需要把参数名写上。比如调用`enroll('Adam', 'M', city='Tianjin')`，意思是，city参数用传进去的值，其他默认参数继续使用默认值。

&ensp;&ensp;&ensp;&ensp;默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：

&ensp;&ensp;&ensp;&ensp;先定义一个函数，传入一个list，添加一个END再返回：


```
def add_end(L=[]):
    L.append('END')
    return L
```

&ensp;&ensp;&ensp;&ensp;正常调用时，结果似乎不错：

```
    >>> add_end([1, 2, 3])
    [1, 2, 3, 'END']
    
    >>> add_end(['x', 'y', 'z'])
    ['x', 'y', 'z', 'END']
```

&ensp;&ensp;&ensp;&ensp;当使用默认参数调用时，一开始结果也是对的：

```
>>> add_end()
['END']
```

&ensp;&ensp;&ensp;&ensp;但是，再次调用add_end()时：

```
>>> add_end()
['END', 'END']
    
>>> add_end()
['END', 'END', 'END']
```

&ensp;&ensp;&ensp;&ensp;原因如下：
>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

&ensp;&ensp;&ensp;&ensp;所以，定义默认参数要牢记一点：`默认参数必须指向不变对象`.

&ensp;&ensp;&ensp;&ensp;要修改上面的例子，我们可以用`None`这个不变对象来实现：

```
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
```

&ensp;&ensp;&ensp;&ensp;现在，无论调用多少次，都不会有问题：

```    
>>> add_end()
['END']
>>> add_end()
['END']
```

&ensp;&ensp;&ensp;&ensp;设计str、None这样的不变对象的原因在于不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

---

## 3.可变参数

```
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```

&ensp;&ensp;&ensp;&ensp;在函数内部，参数numbers接收到的是一个tuple，调用该函数时，可以传入任意个参数，包括0个参数：

```
>>> calc(1, 2)
5

>>> calc()
0
```

&ensp;&ensp;&ensp;&ensp;若已经有一个list或者tuple，要调用一个可变参数：

```
>>> nums = [1, 2, 3]
>>> calc(nums[0], nums[1], nums[2])
14
```

&ensp;&ensp;&ensp;&ensp;简便写法：

```
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
```
&ensp;&ensp;&ensp;&ensp;`*nums`表示把nums这个list的所有元素作为可变参数传进去。

---

### 4.关键字参数

&ensp;&ensp;&ensp;&ensp;关键字参数允许传入0个或任意个`含参数名`的参数，这些关键字参数在函数内部自动组装为一个`dict`。

```
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
```

&ensp;&ensp;&ensp;&ensp;函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：

```
>>> person('Michael', 30)
name: Michael age: 30 other: {}
```

&ensp;&ensp;&ensp;&ensp;也可以传入任意个数的关键字参数：

```
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```

&ensp;&ensp;&ensp;&ensp;关键字参数可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

&ensp;&ensp;&ensp;&ensp;和可变参数类似，也可以先组装出一个`dict`，然后，把该dict转换为关键字参数传进去：

```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

&ensp;&ensp;&ensp;&ensp;简便写法：

```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

&ensp;&ensp;&ensp;&ensp;`**extra`表示把extra这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，kw将获得一个dict，注意kw获得的dict是extra的一份`拷贝`，对kw的改动不会影响到函数外的extra。

---

## 5.命名关键字参数
&ensp;&ensp;&ensp;&ensp;如果要`限制关键字参数的名字`，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：

```
def person(name, age, *, city, job):
    print(name, age, city, job)
```
&ensp;&ensp;&ensp;&ensp;和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。

&ensp;&ensp;&ensp;&ensp;调用方式如下：

```
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
```

&ensp;&ensp;&ensp;&ensp;如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了：

```
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
```

&ensp;&ensp;&ensp;&ensp;命名关键字参数`必须传入参数名`:

```
>>> person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person() takes 2 positional arguments but 4 were given
```

&ensp;&ensp;&ensp;&ensp;由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。

&ensp;&ensp;&ensp;&ensp;命名关键字参数可以有缺省值，从而简化调用：

```
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
```

&ensp;&ensp;&ensp;&ensp;由于命名关键字参数city具有默认值，调用时，可不传入city参数：

```
>>> person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
```

&ensp;&ensp;&ensp;&ensp;使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数：

```
def person(name, age, city, job):    # 缺少 *，city和job被视为位置参数    
	pass
```

---

## 6.参数组合
&ensp;&ensp;&ensp;&ensp;在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：`必选参数、默认参数、可变参数、命名关键字参数和关键字参数`。

```
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
```

&ensp;&ensp;&ensp;&ensp;在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

```
>>> f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
>>> f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
```

&ensp;&ensp;&ensp;&ensp;最神奇的是通过一个tuple和dict，你也可以调用上述函数：

```
>>> args = (1, 2, 3, 4)
>>> kw = {'d': 99, 'x': '#'}
>>> f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
>>> args = (1, 2, 3)
>>> kw = {'d': 88, 'x': '#'}
>>> f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
```

&ensp;&ensp;&ensp;&ensp;所以，对于任意函数，都可以通过类似`func(args, *kw)`的形式调用它，无论它的参数是如何定义的。

---

## 7.递归函数
&ensp;&ensp;&ensp;&ensp;递归函数的优点是`定义简单，逻辑清晰`。理论上，所有的递归函数都可以写成`循环`的方式，但循环的逻辑不如递归清晰。

&ensp;&ensp;&ensp;&ensp;使用递归函数需要注意`防止栈溢出`。在计算机中，函数调用是通过`栈（stack）`这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

&ensp;&ensp;&ensp;&ensp;解决递归调用栈溢出的方法是通过`尾递归优化`，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

&ensp;&ensp;&ensp;&ensp;尾递归是指，`在函数返回的时候，调用自身本身，并且，return语句不能包含表达式`。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

&ensp;&ensp;&ensp;&ensp;上面的fact(n)函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

```
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

&ensp;&ensp;&ensp;&ensp;尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

&ensp;&ensp;&ensp;&ensp;遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

---

# 十、高级特性 {#AdvancedCharacteristics}
## 1.切片（Slice）

&ensp;&ensp;&ensp;&ensp;`L[0:3]`表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2(左闭右开)。

&ensp;&ensp;&ensp;&ensp;如果第一个索引是0，还可以省略：

```
>>> L[:3]
['Michael', 'Sarah', 'Tracy']
```

&ensp;&ensp;&ensp;&ensp;支持倒数切片：

```
>>> L[-2:]
['Bob', 'Jack']
>>> L[-2:-1]
['Bob']
```

&ensp;&ensp;&ensp;&ensp;创建一个0-99的数列：

```
>>> L = list(range(100))
>>> L
[0, 1, 2, 3, ..., 99]

>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
```

&ensp;&ensp;&ensp;&ensp;前10个数，每两个取一个(第三个参数表示`步长`)：

```
>>> L[:10:2]
[0, 2, 4, 6, 8]
```

&ensp;&ensp;&ensp;&ensp;只写`[:]`就可以原样复制一个list：

```
>>> L[:]
[0, 1, 2, 3, ..., 99]
```

&ensp;&ensp;&ensp;&ensp;`tuple`也是一种`list`，唯一区别是`tuple不可变`。因此，tuple也可以用切片操作，只是操作的结果仍是`tuple`：

```
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
```

&ensp;&ensp;&ensp;&ensp;字符串`'xxx'`也可以看成是一种list，每个元素就是一个`字符`。因此，字符串也可以用切片操作，只是操作结果仍是`字符串`：

```
>>> 'ABCDEFG'[:3]
'ABC'

>>> 'ABCDEFG'[::2]
'ACEG'
```

&ensp;&ensp;&ensp;&ensp;在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成。

---

## 2.迭代
&ensp;&ensp;&ensp;&ensp;Python的for循环不仅可以用在list或tuple上，还可以作用在其他`可迭代对象`上。

&ensp;&ensp;&ensp;&ensp;list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：

```
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> for key in d:
...     print(key)
...
a
c
b
```

&ensp;&ensp;&ensp;&ensp;因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

&ensp;&ensp;&ensp;&ensp;默认情况下，dict迭代的是`key`。如果要迭代`value`，可以用`for value in d.values()`，如果要同时迭代key和value，可以用`for k, v in d.items()`。
由于字符串也是可迭代对象，因此，也可以作用于`for循环`：

```
>>> for ch in 'ABC':
...     print(ch)
...
A
B
C
```

&ensp;&ensp;&ensp;&ensp;所以，当我们使用for循环时，只要作用于一个`可迭代对象`，for循环就可以正常运行，所以不用关心该对象究竟是list还是其他数据类型。

&ensp;&ensp;&ensp;&ensp;通过`collections模块`的`Iterable`类型判断：

```
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
```

&ensp;&ensp;&ensp;&ensp;Python内置的`enumerate函数`可以把一个`list`变成`索引-元素`对，这样就可以在for循环中同时迭代索引和元素本身：

```
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
```

&ensp;&ensp;&ensp;&ensp;同时引用了两个变量：

```
>>> for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
```

## 3.列表生成式
&ensp;&ensp;&ensp;&ensp;列表生成式即`List Comprehensions`，是Python内置的非常简单却强大的可以用来创建list的生成式。

&ensp;&ensp;&ensp;&ensp;举个例子，要生成`list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`可以用`list(range(1, 11))`。

&ensp;&ensp;&ensp;&ensp;要生成`[1x1, 2x2, 3x3, ..., 10x10]`就用`[x * x for x in range(1, 11)]`。

&ensp;&ensp;&ensp;&ensp;for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：

```
>>> [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
```

&ensp;&ensp;&ensp;&ensp;还可以使用两层循环，可以生成全排列：

```
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```

&ensp;&ensp;&ensp;&ensp;for循环其实可以同时使用两个甚至多个变量，比如dict的`items()`可以同时迭代`key`和`value`：

```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
...     print(k, '=', v)
...
y = B
x = A
z = C
```

&ensp;&ensp;&ensp;&ensp;因此，列表生成式也可以使用两个变量来生成list：

```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> [k + '=' + v for k, v in d.items()]
['y=B', 'x=A', 'z=C']
```

&ensp;&ensp;&ensp;&ensp;最后把一个list中所有的字符串变成小写：

```
>>> L = ['Hello', 'World', 'IBM', 'Apple']
>>> [s.lower() for s in L]
['hello', 'world', 'ibm', 'apple']
```

## 4.生成器
&ensp;&ensp;&ensp;&ensp;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。如果列表元素可以按照某种算法推算出来，就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为`生成器：generator`。

&ensp;&ensp;&ensp;&ensp;要创建一个generator，有很多种方法。

&ensp;&ensp;&ensp;&ensp;第一种方法只要把一个列表生成式的`[]`改成`()`，就创建了一个generator：

```
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
```

&ensp;&ensp;&ensp;&ensp;如果要一个一个打印出来，可以通过`next()`函数获得generator的`下一个返回值`：

```
>>> next(g)
0
>>> next(g)
1
>>> next(g)
4
>>> next(g)
9
>>> next(g)
16
>>> next(g)
25
>>> next(g)
36
>>> next(g)
49
>>> next(g)
64
>>> next(g)
81
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

&ensp;&ensp;&ensp;&ensp;我们讲过，generator保存的是`算法`，每次调用`next(g)`，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出`StopIteration的错误`。

&ensp;&ensp;&ensp;&ensp;也可使用`for循环`，因为generator也是`可迭代对象`：

```
>>> g = (x * x for x in range(10))
>>> for n in g:
...     print(n)
... 
0
1
4
9
16
25
36
49
64
81
```

&ensp;&ensp;&ensp;&ensp;如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用`函数`来实现。

&ensp;&ensp;&ensp;&ensp;比如，著名的`斐波拉契数列（Fibonacci）`，除第一个和第二个数外，任意一个数都可由前两个数相加得到：

```
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
```

&ensp;&ensp;&ensp;&ensp;斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：

```
def fib(max):
	n, a, b = 0, 0, 1
	while n < max:
	    print(b)
	    a, b = b, a + b
	    n = n + 1
	return 'done'
```	

&ensp;&ensp;&ensp;&ensp;注意，赋值语句：

```
a, b = b, a + b
```

&ensp;&ensp;&ensp;&ensp;相当于：

```
t = (b, a + b) # t是一个tuple
a = t[0]
b = t[1]
```

&ensp;&ensp;&ensp;&ensp;相当于：

```
t = (b, a + b) # t是一个tuple
a = t[0]
b = t[1]
```

&ensp;&ensp;&ensp;&ensp;但不必显式写出临时变量t就可以赋值。

&ensp;&ensp;&ensp;&ensp;上面的函数可以输出斐波那契数列的前N个数：

```
>>> fib(6)
1
1
2
3
5
8
'done'
```

&ensp;&ensp;&ensp;&ensp;仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。

&ensp;&ensp;&ensp;&ensp;也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把`print(b)`改为`yield b`就可以了：

```
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
```

&ensp;&ensp;&ensp;&ensp;这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：

```
>>> f = fib(6)
>>> f
<generator object fib at 0x104feaaa0>
```

&ensp;&ensp;&ensp;&ensp;这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到`yield`语句返回，再次执行时从`上次返回的yield语句处`继续执行。
举个简单的例子，定义一个generator，依次返回数字1，3，5：

```
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
    yield(5)
```

&ensp;&ensp;&ensp;&ensp;调用该generator时，首先要生成一个`generator对象`，然后用next()函数不断获得下一个返回值：

```
>>> o = odd()
>>> next(o)
step 1
1
>>> next(o)
step 2
3
>>> next(o)
step 3
5
>>> next(o)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

&ensp;&ensp;&ensp;&ensp;可以看到，`odd`不是普通函数，而是`generator`，在执行过程中，遇到`yield`就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。

&ensp;&ensp;&ensp;&ensp;回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。
同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：

```
>>> for n in fib(6):
...     print(n)
...
1
1
2
3
5
8
```

&ensp;&ensp;&ensp;&ensp;但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：

```
>>> g = fib(6)
>>> while True:
...     try:
...         x = next(g)
...         print('g:', x)
...     except StopIteration as e:
...         print('Generator return value:', e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
```

## 5.迭代器
&ensp;&ensp;&ensp;&ensp;我们已经知道，可以直接作用于for循环的数据类型有以下几种：

- 一类是`集合数据类型`，如list、tuple、dict、set、str等；
- 一类是`generator`，包括生成器和带yield的generator function。

&ensp;&ensp;&ensp;&ensp;这些可以直接作用于for循环的对象统称为`可迭代对象：Iterable`。
可以使用`isinstance()`判断一个对象是否是`Iterable对象`：

```
>>> from collections import Iterable
>>> isinstance([], Iterable)
True
>>> isinstance({}, Iterable)
True
>>> isinstance('abc', Iterable)
True
>>> isinstance((x for x in range(10)), Iterable)
True
>>> isinstance(100, Iterable)
False
```

&ensp;&ensp;&ensp;&ensp;而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。

&ensp;&ensp;&ensp;&ensp;可以被next()函数调用并不断返回下一个值的对象称为`迭代器：Iterator`。

&ensp;&ensp;&ensp;&ensp;可以使用`isinstance()`判断一个对象是否是`Iterator对象`：

```
>>> from collections import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
>>> isinstance([], Iterator)
False
>>> isinstance({}, Iterator)
False
>>> isinstance('abc', Iterator)
False
```

&ensp;&ensp;&ensp;&ensp;生成器都是Iterator对象，但list、dict、str虽然是`Iterable`，却不是`Iterator`。

&ensp;&ensp;&ensp;&ensp;把list、dict、str等Iterable变成Iterator可以使用`iter()`函数：

```
>>> isinstance(iter([]), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True
```

&ensp;&ensp;&ensp;&ensp;因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。

&ensp;&ensp;&ensp;&ensp;Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。

## 小结
&ensp;&ensp;&ensp;&ensp;凡是`可作用于for循环的对象`都是`Iterable类型`；

&ensp;&ensp;&ensp;&ensp;凡是`可作用于next()函数`的对象都是`Iterator类型`，它们表示一个`惰性计算`的序列；

&ensp;&ensp;&ensp;&ensp;集合数据类型如`list、dict、str`等是`Iterable`但不是Iterator，不过可以通过`iter()`函数获得一个`Iterator对象`。

&ensp;&ensp;&ensp;&ensp;Python的for循环本质上就是通过`不断调用next()函数`实现的，例如：

``` 
   for x in [1, 2, 3, 4, 5]:
        pass
```

&ensp;&ensp;&ensp;&ensp;实际上完全等价于：

```
# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
```

---

# 十一、函数式编程 {#FunctionalProgramming}
&ensp;&ensp;&ensp;&ensp;函数式编程就是一种`抽象程度很高`的编程范式，纯粹的函数式编程语言编写的函数`没有变量`，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为`没有副作用`。而允许使用变量的程序设计语言，由于函数内部的变量状态`不确定`，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

&ensp;&ensp;&ensp;&ensp;函数式编程的一个特点就是，允许把`函数本身`作为`参数`传入另一个函数，还允许返回一个`函数`。

&ensp;&ensp;&ensp;&ensp;Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是`纯`函数式编程语言。

---

## 1.高阶函数
&ensp;&ensp;&ensp;&ensp;以Python内置的求绝对值的函数`abs()`为例，`abs(-10)`是`函数调用`，而abs是`函数本身``。

&ensp;&ensp;&ensp;&ensp;函数本身也可以赋值给变量，即变量可以指向函数。

&ensp;&ensp;&ensp;&ensp;如果一个变量指向了一个函数，可通过该变量来调用这个函数：


```
>>> f = abs
>>> f(-10)
10
```

&ensp;&ensp;&ensp;&ensp;说明变量f现在已经指向了`abs函数`本身。直接调用`abs()函数`和调用变量`f()`完全相同。

&ensp;&ensp;&ensp;&ensp;`函数名其实就是指向函数的变量`。

---

### 传入函数
&ensp;&ensp;&ensp;&ensp;一个函数就可以接收另一个函数作为参数，这种函数就称之为`高阶函数`。

&ensp;&ensp;&ensp;&ensp;一个最简单的高阶函数：

```
def add(x, y, f):
    return f(x) + f(y)
```

&ensp;&ensp;&ensp;&ensp;当我们调用`add(-5, 6, abs)`时，参数`x，y`和`f``分别接收-5，6和abs`，根据函数定义，我们可以推导计算过程为：

```
x = -5
y = 6
f = abs
f(x) + f(y) ==> abs(-5) + abs(6) ==> 11
return 11
```

&ensp;&ensp;&ensp;&ensp;用代码验证一下：

```
>>>add(-5, 6, abs)      
11      
```        

&ensp;&ensp;&ensp;&ensp;编写高阶函数，就是让函数的参数能够`接收别的函数`。

---

### map和reduce
&ensp;&ensp;&ensp;&ensp;`map()`函数接收两个参数，一个是`函数`，一个是`Iterable`，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

```
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

&ensp;&ensp;&ensp;&ensp;`reduce`把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：

```
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
```

### filter
&ensp;&ensp;&ensp;&ensp;Python内建的`filter()`函数用于过滤序列。

&ensp;&ensp;&ensp;&ensp;和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定`保留还是丢弃`该元素。

例如，在一个list中，删掉偶数，只保留奇数，可以这么写：

```
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```

&ensp;&ensp;&ensp;&ensp;可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。

&ensp;&ensp;&ensp;&ensp;注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得`所有结果`并返回list。

---

### sorted
&ensp;&ensp;&ensp;&ensp;Python内置的sorted()函数就可以对list进行排序：

```
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
```

&ensp;&ensp;&ensp;&ensp;此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：

```
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```

&ensp;&ensp;&ensp;&ensp;key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：

```
list = [36, 5, -12, 9, -21]

keys = [36, 5,  12, 9,  21]
```

&ensp;&ensp;&ensp;&ensp;然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：

```
keys排序结果 => [5, 9,  12,  21, 36] 
最终结果     => [5, 9, -12, -21, 36]  
```

&ensp;&ensp;&ensp;&ensp;我们再看一个字符串排序的例子：

```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
```

&ensp;&ensp;&ensp;&ensp;默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。

&ensp;&ensp;&ensp;&ensp;现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
这样，我们给sorted传入key函数，即可实现忽略大小写的排序：

```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
```

&ensp;&ensp;&ensp;&ensp;要进行反向排序，不必改动key函数，可以传入第三个参数`reverse=True`：

```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```

&ensp;&ensp;&ensp;&ensp;从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。

---

## 2.返回函数
&ensp;&ensp;&ensp;&ensp;高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

&ensp;&ensp;&ensp;&ensp;下面实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：

```
def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax
```

&ensp;&ensp;&ensp;&ensp;但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算,就可以不返回求和的结果，而是返回求和的函数：

```
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
```

&ensp;&ensp;&ensp;&ensp;当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：

```
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
```

&ensp;&ensp;&ensp;&ensp;调用函数f时，才真正计算求和的结果：

```
>>> f()
25
```

&ensp;&ensp;&ensp;&ensp;在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：

```
>>> f1 = lazy_sum(1, 3, 5, 7, 9)
>>> f2 = lazy_sum(1, 3, 5, 7, 9)
>>> f1==f2
False
```

&ensp;&ensp;&ensp;&ensp;f1()和f2()的调用结果互不影响。

---

### 闭包
&ensp;&ensp;&ensp;&ensp;注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。

&ensp;&ensp;&ensp;&ensp;另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：

```
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
```

&ensp;&ensp;&ensp;&ensp;在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。

&ensp;&ensp;&ensp;&ensp;你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：

```
>>> f1()
9
>>> f2()
9
>>> f3()
9
```

&ensp;&ensp;&ensp;&ensp;全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

&ensp;&ensp;&ensp;&ensp;返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

&ensp;&ensp;&ensp;&ensp;如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
```

&ensp;&ensp;&ensp;&ensp;再看看结果：

```
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9
```

&ensp;&ensp;&ensp;&ensp;匿名函数`lambda x: x * x`实际上就是：

```
def f(x):    
	return x * x
```

&ensp;&ensp;&ensp;&ensp;关键字`lambda`表示匿名函数，冒号前面的x表示函数参数。

&ensp;&ensp;&ensp;&ensp;匿名函数有个限制，就是`只能有一个表达式`，不用写return，返回值就是该表达式的结果。

&ensp;&ensp;&ensp;&ensp;用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：


---

## 3.匿名函数

```
>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25
```

&ensp;&ensp;&ensp;&ensp;同样，也可以把匿名函数作为返回值返回，比如：

```
def build(x, y):
    return lambda: x * x + y * y
```

## 4.装饰器
&ensp;&ensp;&ensp;&ensp;由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。

```
>>> def now():
...     print('2015-3-25')
...
>>> f = now
>>> f()
2015-3-25
```

&ensp;&ensp;&ensp;&ensp;函数对象有一个__name__属性，可以拿到函数的名字：

```
>>> now.__name__
'now'
>>> f.__name__
'now'
```

&ensp;&ensp;&ensp;&ensp;现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

&ensp;&ensp;&ensp;&ensp;本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：

```
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

&ensp;&ensp;&ensp;&ensp;观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

```
@log
def now():
    print('2015-3-25')
```

&ensp;&ensp;&ensp;&ensp;调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：

```
>>> now()
call now():
2015-3-25
```

&ensp;&ensp;&ensp;&ensp;把@log放到now()函数的定义处，相当于执行了语句：

```
now = log(now)
```

&ensp;&ensp;&ensp;&ensp;由于``log()是一个`decorator`，返回一个函数，所以，原来的`now()`函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在`log()`函数中返回的`wrapper()`函数。

&ensp;&ensp;&ensp;&ensp;`wrapper()`函数的参数定义是`(args, *kw)`，因此，`wrapper()``函数可以接受任意参数的调用。在wrapper()`函数内，首先打印日志，再紧接着调用原始函数。

&ensp;&ensp;&ensp;&ensp;如果decorator本身需要传入参数，那就需要编写一个`返回decorator`的高阶函数，写出来会更复杂。比如，要自定义log的文本：

```
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

&ensp;&ensp;&ensp;&ensp;这个3层嵌套的decorator用法如下：

```
@log('execute')
def now():
    print('2015-3-25')
```

&ensp;&ensp;&ensp;&ensp;执行结果如下：

```
>>> now()
execute now():
2015-3-25
```

&ensp;&ensp;&ensp;&ensp;和两层嵌套的decorator相比，3层嵌套的效果是这样的：

```
>>> now = log('execute')(now)
```

&ensp;&ensp;&ensp;&ensp;我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。
以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：

```
>>> now.__name__
'wrapper'
```

&ensp;&ensp;&ensp;&ensp;因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。
不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：

```
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

&ensp;&ensp;&ensp;&ensp;或者针对带参数的decorator：

```
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

&ensp;&ensp;&ensp;&ensp;`import functools`是导入`functools模块`。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。

---

## 5.偏函数
&ensp;&ensp;&ensp;&ensp;Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。

&ensp;&ensp;&ensp;&ensp;在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：

&ensp;&ensp;&ensp;&ensp;int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：

```
>>> int('12345')
12345
```

&ensp;&ensp;&ensp;&ensp;但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：

```
>>> int('12345', base=8)
5349
>>> int('12345', 16)
74565
```

&ensp;&ensp;&ensp;&ensp;假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：

```
def int2(x, base=2):
    return int(x, base)
```

&ensp;&ensp;&ensp;&ensp;这样，我们转换二进制就非常方便了：

```
>>> int2('1000000')
64
>>> int2('1010101')
85
```

&ensp;&ensp;&ensp;&ensp;`functools.partial`就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：

```
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
```

&ensp;&ensp;&ensp;&ensp;所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：

```
>>> int2('1000000', base=10)
1000000
```

&ensp;&ensp;&ensp;&ensp;最后，创建偏函数时，实际上可以接收函数对象、args和*kw这3个参数，当传入：

```
int2 = functools.partial(int, base=2)
```

&ensp;&ensp;&ensp;&ensp;实际上固定了int()函数的关键字参数base，也就是：

```
int2('10010')
```

&ensp;&ensp;&ensp;&ensp;相当于：

```
kw = { 'base': 2 }
int('10010', **kw)
```

&ensp;&ensp;&ensp;&ensp;当传入：

```
max2 = functools.partial(max, 10)
```

&ensp;&ensp;&ensp;&ensp;实际上会把10作为*args的一部分自动加到左边，也就是：

```
max2(5, 6, 7)
```

&ensp;&ensp;&ensp;&ensp;相当于：

```
args = (10, 5, 6, 7)
max(*args)
#结果为10
```
---

# 十二、模块 {#Module}
&ensp;&ensp;&ensp;&ensp;在Python中，一个`.py`文件就称之为一个`模块（Module）`。

&ensp;&ensp;&ensp;&ensp;使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，`不必考虑`名字会与其他模块冲突。但是也要注意，尽量不要与`内置函数`名字冲突。

&ensp;&ensp;&ensp;&ensp;
为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为`包（Package）`。

&ensp;&ensp;&ensp;&ensp;举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。

&ensp;&ensp;&ensp;&ensp;现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：

![](http://os738issp.bkt.clouddn.com/2018/1/2-下午5:19:06.png)

&ensp;&ensp;&ensp;&ensp;引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。

&ensp;&ensp;&ensp;&ensp;每一个包目录下面都会有一个`__init__.py`的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。`__init__.py`可以是空文件，也可以有Python代码，因为`__init__.py本身就是一个模块，而它的模块名就是mycompany`。

&ensp;&ensp;&ensp;&ensp;类似的，可以有多级目录，组成多级层次的包结构。

&ensp;&ensp;&ensp;&ensp;自己创建模块时要注意命名，不能和Python`自带的模块`名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。

---

## 1.使用模块

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
```

&ensp;&ensp;&ensp;&ensp;第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；

&ensp;&ensp;&ensp;&ensp;第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；

&ensp;&ensp;&ensp;&ensp;第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；

&ensp;&ensp;&ensp;&ensp;以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。

&ensp;&ensp;&ensp;&ensp;后面开始就是真正的代码部分。

&ensp;&ensp;&ensp;&ensp;使用sys模块的第一步，就是导入该模块：

```
import sys
```

&ensp;&ensp;&ensp;&ensp;导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。

&ensp;&ensp;&ensp;&ensp;sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：

&ensp;&ensp;&ensp;&ensp;运行`python3 hello.py`获得的`sys.argv`就是`['hello.py']`；

&ensp;&ensp;&ensp;&ensp;运行`python3 hello.py Michael`获得的`sys.argv`就是`['hello.py', 'Michael]`。

&ensp;&ensp;&ensp;&ensp;最后，注意到这两行代码：

```
if __name__=='__main__':
    test()
```

&ensp;&ensp;&ensp;&ensp;当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

我们可以用命令行运行hello.py看看效果：

```
$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!
```

&ensp;&ensp;&ensp;&ensp;如果启动Python交互环境，再导入hello模块：

```
$ python3
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import hello
>>>
```

&ensp;&ensp;&ensp;&ensp;导入时，没有打印Hello, word!，因为没有执行`test()`函数。

&ensp;&ensp;&ensp;&ensp;调用hello.test()时，才能打印出Hello, word!：

```
>>> hello.test()
Hello, world!
```

---

### 作用域
&ensp;&ensp;&ensp;&ensp;在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。
正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；

&ensp;&ensp;&ensp;&ensp;类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，`hello模块`定义的文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名；

&ensp;&ensp;&ensp;&ensp;类似`_xxx`和`__xxx`这样的函数或变量就是`非公开的（private）`，不应该被直接引用，比如_abc，__abc等；

&ensp;&ensp;&ensp;&ensp;之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

&ensp;&ensp;&ensp;&ensp;private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：

```
def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)
```

&ensp;&ensp;&ensp;&ensp;我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：

&ensp;&ensp;&ensp;&ensp;外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。

---

## 2.安装第三方模块  

&ensp;&ensp;&ensp;&ensp;在Python中，安装第三方模块，是通过包管理工具`pip`完成的。

&ensp;&ensp;&ensp;&ensp;如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。

&ensp;&ensp;&ensp;&ensp;如果你正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path。

&ensp;&ensp;&ensp;&ensp;在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。

&ensp;&ensp;&ensp;&ensp;注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是`pip3`。

&ensp;&ensp;&ensp;&ensp;现在，让我们来安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。

&ensp;&ensp;&ensp;&ensp;一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：

```
pip install Pillow
```

&ensp;&ensp;&ensp;&ensp;耐心等待下载并安装后，就可以使用Pillow了。
有了Pillow，处理图片易如反掌。随便找个图片生成缩略图：

```
>>> from PIL import Image
>>> im = Image.open('test.png')
>>> print(im.format, im.size, im.mode)
PNG (400, 300) RGB
>>> im.thumbnail((200, 100))
>>> im.save('thumb.jpg', 'JPEG')
```

&ensp;&ensp;&ensp;&ensp;其他常用的第三方库还有MySQL的驱动：mysql-connector-python，用于科学计算的NumPy库：numpy，用于生成文本的模板工具Jinja2，等等。

---

### 模块搜索路径
&ensp;&ensp;&ensp;&ensp;当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：

```
>>> import mymodule
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named mymodule
```

&ensp;&ensp;&ensp;&ensp;默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：

```
>>> import sys
>>> sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python34.zip', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/plat-darwin', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages']
```

&ensp;&ensp;&ensp;&ensp;如果我们要添加自己的搜索目录，有两种方法：
&ensp;&ensp;&ensp;&ensp;一是直接修改sys.path，添加要搜索的目录：

```
>>> import sys
>>> sys.path.append('/Users/michael/my_py_scripts')
```

&ensp;&ensp;&ensp;&ensp;这种方法是在运行时修改，运行结束后失效。

&ensp;&ensp;&ensp;&ensp;第二种方法是设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。

---

# 十三、面向对象编程 {#ObjectOrientedProgramming}


## 类和实例

### 定义类：

```
class Student(object):
    pass

```

---

### 创建实例：

```
>>> bart = Student()
>>> bart
<__main__.Student object at 0x10a67a590>

>>> Student
<class '__main__.Student'>
```

---

### 给实例绑定属性：

```
>>> bart.name = 'Bart Simpson'
>>> bart.name
'Bart Simpson'
```

---

### `__init__`方法（构造方法）：

```
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
```

第一个参数永远是`self`，表示创建的实例本身
在创建实例的时候，必须传入`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去.

---

## 数据封装

```
class Student(object):
	...

   def get_grade(self):
       if self.score >= 90:
           return 'A'
       elif self.score >= 60:
           return 'B'
       else:
           return 'C'
```

---

## 访问限制
###私有变量（private）
以`__`(双下划线)开头的变量，只有内部可以访问，外部不能访问，可通过设置get方法和set方法访问或修改。

```
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
        
```

---

### 特殊变量
以`双下划线`开头，并且以`双下划线`结尾的，类似`__xxx__`,可以直接访问的，不是private变量

不能直接访问`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量：

```
>>> bart._Student__name
'Bart Simpson'
```
但是不同版本的Python解释器可能会把__name改成不同的变量名。
总的来说就是，Python本身没有任何机制阻止干坏事，一切全靠`自觉`。

---

易错点：

```
>>> bart = Student('Bart Simpson', 98)
>>> bart.get_name()
'Bart Simpson'
>>> bart.__name = 'New Name' # 设置__name变量！
>>> bart.__name
'New Name'
```
表面上看，外部代码“成功”地设置了`__name`变量，但实际上这个`__name`变量和class内部的`__name`变量不是一个变量！内部的`__name`变量已经被Python解释器自动改成了`_Student__name`，而外部代码给bart新增了一个`__name`变量。

```
>>> bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'  
```

---

## 继承和多态
### 继承

```
class Animal(object):
    def run(self):
        print('Animal is running...')
        
class Dog(Animal):
    pass

class Cat(Animal):
    pass
```

继承的好处是子类获得了父类的全部功能。由于`Animial`实现了`run()`方法，因此，`Dog`和`Cat`作为它的子类，也拥有了`run()`方法：

```
dog = Dog()
dog.run()

cat = Cat()
cat.run()
```

运行结果如下：

```
Animal is running...
Animal is running...
```

---

### 多态
```
class Dog(Animal):

    def run(self):
        print('Dog is running...')

class Cat(Animal):

    def run(self):
        print('Cat is running...')
```
 当子类和父类都存在相同的run()方法时，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。
 
 当定义一个class的时候，实际上就定义了一种数据类型。
 
```
a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
```

判断一个变量是否是某个类型可以用 `isinstance()`判断：

```
>>> isinstance(a, list)
True
>>> isinstance(b, Animal)
True
>>> isinstance(c, Dog)
True
```

所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是反过来就不行：

```
>>> b = Animal()
>>> isinstance(b, Dog)
False
```
---

###“开闭”原则：
- 对扩展开放：允许新增子类；
- 对修改封闭：不需要修改依赖Animal类型的函数。

### 静态语言 vs 动态语言
对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是`Animal类型或者它的子类`，否则，将无法调用`run()`方法。
对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象`有一个run()方法`就可以了：

```
class Timer(object):
    def run(self):
        print('Start...')
```

这就是动态语言的`“鸭子类型”`，它并不要求严格的继承体系，一个对象只要`“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子`。

Python的`“file-like object”`就是一种鸭子类型。对真正的文件对象，它有一个`read()`方法，返回其内容。但是，许多对象，只要有`read()`方法，都被视为`“file-like object”`。许多函数接收的参数就是`“file-like object“`，你不一定要传入真正的文件对象，完全可以传入任何实现了`read()`方法的对象。

---

### 获取对象信息
使用`type()`，判断对象类型：

```
>>> type(123)
<class 'int'>
>>> type('str')
<class 'str'>
>>> type(None)
<type(None) 'NoneType'>
```

如果一个变量指向函数或者类，也可以用`type()`判断：

```
>>> type(abs)
<class 'builtin_function_or_method'>
>>> type(a)
<class '__main__.Animal'>
```

`type()`函数返回的对应的Class类型。

```
>>> type(123)==type(456)
True
>>> type(123)==int
True
>>> type('abc')==type('123')
True
>>> type('abc')==str
True
>>> type('abc')==type(123)
False


>>> type(fn)==types.FunctionType
True
>>> type(abs)==types.BuiltinFunctionType
True
>>> type(lambda x: x)==types.LambdaType
True
>>> type((x for x in range(10)))==types.GeneratorType
True
```

---

### 使用`isinstance()`
判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。

```
>>> a = Animal()
>>> d = Dog()
>>> h = Husky()

>>> isinstance(h, Husky)
True
```

---
### 使用`dir()`
获得一个对象的所有属性和方法，返回一个包含字符串的`list`.

类似`__xxx__`的属性和方法在Python中都是有特殊用途的，比如`__len__`方法返回长度。在Python中，如果你调用`len()`函数试图获取一个对象的长度，实际上，在`len()`函数内部，它自动去调用该对象的`__len__()`方法.
所以，下面的代码是等价的：

```
>>> len('ABC')
3
>>> 'ABC'.__len__()
3
```

我们自己写的类，如果也想用`len(myObj)`的话，就自己写一个`__len__()`方法.

### 其他方法：
```
>>> class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
>>> obj = MyObject()

>>> hasattr(obj, 'x') # 有属性'x'吗？
True
>>> obj.x
9
>>> hasattr(obj, 'y') # 有属性'y'吗？
False
>>> setattr(obj, 'y', 19) # 设置一个属性'y'
>>> hasattr(obj, 'y') # 有属性'y'吗？
True
>>> getattr(obj, 'y') # 获取属性'y'
19
>>> obj.y # 获取属性'y'
19
```

如果试图获取不存在的属性，会抛出`AttributeError`的错误。

可以传入一个`default`参数，如果属性不存在，就返回默认值：

```
>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
```

也可以获得对象的方法：

```
>>> hasattr(obj, 'power') # 有属性'power'吗？
True
>>> getattr(obj, 'power') # 获取属性'power'
<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>
>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
>>> fn # fn指向obj.power
<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>
>>> fn() # 调用fn()与调用obj.power()是一样的
81
```

---

## 实例属性和类属性
Python是动态语言，根据类创建的实例可以任意绑定属性。
给实例绑定属性的方法是通过实例变量，或者通过`self`变量：

```
class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
```

应避免把`实例属性`和`类属性`使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当删除实例属性后，再使用相同的名称，访问到的将是`类属性`。

---

## 面向对象高级编程
### `__slots__`
限制该class实例能添加的属性：

```
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称

```

由于`'score'`没有被放到`__slots__`中，所以不能绑定score属性，试图绑定score将得到`AttributeError`的错误。

使用`__slots__`要注意，`__slots__`定义的属性仅对`当前类实例`起作用，对继承的子类是不起作用的。

除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是`自身的__slots__`加上`父类的__slots__`。

---
### `@property`装饰器
负责把一个方法变成属性调用的：

```
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value

```

```
>>> s = Student()
>>> s.score = 60 # OK，实际转化为s.set_score(60)
>>> s.score # OK，实际转化为s.get_score()
60
>>> s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
```

我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过`getter`和`setter`方法来实现的。
还可以定义`只读属性`，只定义getter方法，不定义setter方法就是一个只读属性：

```
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
```
上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。

---

### 多重继承
```
class Dog(Mammal, Runnable):
    pass
```

### MixIn

在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为`MixIn`。

为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：

```
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```

MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

---

## 定制类
### `__str__`

先定义一个Student类，打印一个实例：

```
>>> class Student(object):
...     def __init__(self, name):
...         self.name = name
...
>>> print(Student('Michael'))
<__main__.Student object at 0x109afb190>
```

```
>>> class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
>>> print(Student('Michael'))
Student object (name: Michael)
```

```
>>> s = Student('Michael')
>>> s
<__main__.Student object at 0x109afb310>
```

直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。
解决办法是再定义一个`__repr__()`。但是通常`__str__()`和`__repr__()`代码都是一样的，所以，有个偷懒的写法：

```
class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
```

---

### `__iter__`
如果一个类想被用于`for ... in`循环，类似list或tuple那样，就必须实现一个`__iter__()`方法，该方法`返回一个迭代对象`，然后，Python的for循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到`StopIteration`错误时退出循环。
以斐波那契数列为例，写一个Fib类，可以作用于for循环：

```
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
```

现在，试试把Fib实例作用于for循环：

```
>>> for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
```

---

### `__getitem__`
要表现得像list那样按照下标取出元素，需要实现`__getitem__()`方法：

```
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
```

现在，就可以按下标访问数列的任意一项了：

```
>>> f = Fib()
>>> f[0]
1
>>> f[1]
1
>>> f[2]
```

但若要使用`切片方法`还需要很多工作。

与之对应的是`__setitem__()`方法，把对象视作`list或dict`来对集合赋值。最后，还有一个`__delitem__()`方法，用于删除某个元素。

总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口.

---

### `__getattr__`

```
class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
```

当调用不存在的属性时，比如score，Python解释器会试图调用`__getattr__(self, 'score')`来尝试获得属性，这样，我们就有机会返回score的值。

同样，也可以返回函数。

此外，注意到任意调用如s.abc都会返回`None`，这是因为我们定义的`__getattr__`默认返回就是`None`。要让class只响应特定的几个属性，我们就要按照约定，抛出`AttributeError`的错误：

```
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
```

这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。
这种完全动态调用的特性的实际作用就是，可以针对完全动态的情况作调用。
举个例子：
现在很多网站都搞`RST API`，比如新浪微博、豆瓣啥的，调用API的URL类似：

```
http://api.server/user/friends
http://api.server/user/timeline/list
```

如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。
利用完全动态的__getattr__，我们可以写出一个链式调用：

```
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
```

试试：

```
>>> Chain().status.user.timeline.list
'/status/user/timeline/list'
```

这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！
还有些REST API会把参数放到URL中，比如GitHub的API：

```
GET /users/:user/repos
```

调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：

```
Chain().users('michael').repos
```

---

### `__call__`

一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用`instance.method()`来调用。
任何类，只需要定义一个`__call__()`方法，就可以直接对实例进行调用。请看示例：

```
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
```

调用方式如下：
```
>>> s = Student('Michael')
>>> s() # self参数不要传入
My name is Michael.
```

`__call__()`还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。

```
>>> callable(Student())
True
>>> callable(max)
True
>>> callable([1, 2, 3])
False
>>> callable(None)
False
>>> callable('str')
False
```

通过`callable()`函数，我们就可以判断一个对象是否是“可调用”对象。

---
### 枚举类
```
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
```

这样就获得了`Month`类型的枚举类，可以直接使用`Month.Jan`来引用一个常量，或者枚举它的所有成员：

```
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
```

value属性则是自动赋给成员的int常量，默认从1开始计数。
如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：

```
from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```

`@unique`装饰器可以帮助我们检查保证没有重复值。

```
>>> day1 = Weekday.Mon
>>> print(day1)
Weekday.Mon
>>> print(Weekday.Tue)
Weekday.Tue
>>> print(Weekday['Tue'])
Weekday.Tue
>>> print(Weekday.Tue.value)
2
>>> print(day1 == Weekday.Mon)
True
>>> print(day1 == Weekday.Tue)
False
>>> print(Weekday(1))
Weekday.Mon
>>> print(day1 == Weekday(1))
True
>>> Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday
>>> for name, member in Weekday.__members__.items():
...     print(name, '=>', member)
...
Sun => Weekday.Sun
Mon => Weekday.Mon
Tue => Weekday.Tue
Wed => Weekday.Wed
Thu => Weekday.Thu
Fri => Weekday.Fri
Sat => Weekday.Sat
```

可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。

---

### 使用元类
```
>>> from hello import Hello
>>> h = Hello()
>>> h.hello()
Hello, world.
>>> print(type(Hello))
<class 'type'>
>>> print(type(h))
<class 'hello.Hello'>
```
`type()`函数可以查看一个类型或变量的类型，`Hello`是一个`class`，它的类型就是`type`，而`h`是一个实例，它的类型就是`class Hello`。
我们说`class`的定义是运行时动态创建的，而创建`class`的方法就是使用`type()`函数。
`type()`函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过`type()`函数创建出`Hello`类，而无需通过`class Hello(object)...`的定义：

```
>>> def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
>>> Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
>>> h = Hello()
>>> h.hello()
Hello, world.
>>> print(type(Hello))
<class 'type'>
>>> print(type(h))
<class '__main__.Hello'>
```

要创建一个class对象，type()函数依次传入3个参数：  

* class的名称；
* 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
* class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。

通过`type()`函数创建的类和直接写`class`是完全一样的，因为Python解释器遇到`class`定义时，仅仅是扫描一下`class`定义的语法，然后调用`type()`函数创建出`class`。

正常情况下，我们都用`class Xxx...`来定义类，但是，`type()`函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。

---

### metaclass

`metaclass`，直译为`元类`,可以把`类`看成是`metaclass`创建出来的“实例”。
先定义metaclass，就可以创建类，最后创建实例。

详细介绍请看原教程

---

# 十四、错误、调试和测试 {#Error}
## 错误处理
### try

```
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')
```
上面的代码在计算10 / 0时会产生一个除法运算错误：

```
try...
except: division by zero
finally...
END
```

可以有多个except来捕获不同类型的错误：

```
try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
```

如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句：

```
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')
```

Python的错误其实也是`class`，所有的错误类型都继承自`BaseException`，所以在使用`except`时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：

```
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
```

第二个`except`永远也捕获不到`UnicodeError`，因为`UnicodeError`是`ValueError`的子类，如果有，也被`第一个except`给捕获了。

Python所有的错误都是从`BaseException`类派生的，常见的错误类型和继承关系看这里：

[https://docs.python.org/3/library/exceptions.html#exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

使用`try...except`捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理：

```
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
```

也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写`try...except...finally`的麻烦。

---

### 调用堆栈

如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看err.py：

```
def foo(s):    return 10 / int(s)
def bar(s):    return foo(s) * 2
def main():    bar('0')
```

main()执行，结果如下：

```
$ python3 err.py
Traceback (most recent call last):
  File "err.py", line 11, in <module>
    main()
  File "err.py", line 9, in main
    bar('0')
  File "err.py", line 6, in bar
    return foo(s) * 2
  File "err.py", line 3, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
```

出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：
错误信息第1行：

```
Traceback (most recent call last):
```

告诉我们这是错误的跟踪信息。
第2~3行：

```
  File "err.py", line 11, in <module>
    main()
```

调用`main()`出错了，在代码文件err.py的第11行代码，但原因是第9行：

```
  File "err.py", line 9, in main
    bar('0')
```

调用`bar('0')`出错了，在代码文件`err.py`的第9行代码，但原因是第6行：
```
  File "err.py", line 6, in bar
    return foo(s) * 2
```

原因是`return foo(s) * 2`这个语句出错了，但这还不是最终原因，继续往下看：

```
  File "err.py", line 3, in foo
    return 10 / int(s)
```

原因是`return 10 / int(s)`这个语句出错了，这是错误产生的源头，因为下面打印了：

```
ZeroDivisionError: integer division or modulo by zero
```

根据错误类型`ZeroDivisionError`，我们判断，`int(s)`本身并没有出错，但是`int(s)`返回0，在计算`10 / 0`时出错，至此，找到错误源头。

---

### 记录错误

Python内置的`logging模块`可以非常容易地记录错误信息：

```
# err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')
```

同样是出错，但程序打印完错误信息后会继续执行，并正常退出：

```
$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File "err_logging.py", line 13, in main
    bar('0')
  File "err_logging.py", line 9, in bar
    return foo(s) * 2
  File "err_logging.py", line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END
```

通过配置，logging还可以把错误记录到`日志文件`里，方便事后排查。

---

### 抛出错误
因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。
如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例：

```
# err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')
```

执行，可以最后跟踪到我们自己定义的错误：

```
$ python3 err_raise.py 
Traceback (most recent call last):
  File "err_throw.py", line 11, in <module>
    foo('0')
  File "err_throw.py", line 8, in foo
    raise FooError('invalid value: %s' % s)
__main__.FooError: invalid value: 0
```

只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。
最后，我们来看另一种错误处理的方式：

```
# err_reraise.py

def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise

bar()
```
在bar()函数中，我们明明已经捕获了错误，但是，打印一个ValueError!后，又把错误通过raise语句抛出去了，这不有病么？
其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。
raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：

```
try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
```

只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。

---

### 小结

Python内置的try...except...finally用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。
程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。

---

## 调试

第一种方法简单直接粗暴有效，就是用`print()`把可能有问题的变量打印出来看看：

```
def foo(s):
    n = int(s)
    print('>>> n = %d' % n)
    return 10 / n

def main():
    foo('0')

main()
```

执行后在输出中查找打印的变量值：
```
$ python3 err.py
>>> n = 0
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
```

用`print()`最大的坏处是将来还得删掉它，想想程序里到处都是`print()`，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。

---

### 断言

凡是用print()来辅助查看的地方，都可以用断言`（assert）`来替代：

```
def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n

def main():
    foo('0')
```

assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。
如果断言失败，assert语句本身就会抛出AssertionError：

```
$ python3 err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
```

程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：

```
$ python3 -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero
```

关闭后，你可以把所有的assert语句当成pass来看。

### logging


把`print()`替换为`logging`是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件：

```
import logging

s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
```

`logging.info()`就可以输出一段文本。运行，发现除了`ZeroDivisionError`，没有任何信息。怎么回事？
别急，在import logging之后添加一行配置再试试：

```
import logging
logging.basicConfig(level=logging.INFO)
```

看到输出了：

```
$ python3 err.py
INFO:root:n = 0
Traceback (most recent call last):
  File "err.py", line 8, in <module>
    print(10 / n)
ZeroDivisionError: division by zero
```

这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。
logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。

### pdb

第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：

```
# err.py
s = '0'
n = int(s)
print(10 / n)
```

然后启动：

```
$ python3 -m pdb err.py
> /Users/michael/Github/learn-python3/samples/debug/err.py(2)<module>()
-> s = '0'
```
以参数-m pdb启动后，pdb定位到下一步要执行的代码-> s = '0'。输入命令l来查看代码：

```
(Pdb) l
  1     # err.py
  2  -> s = '0'
  3     n = int(s)
  4     print(10 / n)
```
输入命令n可以单步执行代码：

```
(Pdb) n
> /Users/michael/Github/learn-python3/samples/debug/err.py(3)<module>()
-> n = int(s)
(Pdb) n
> /Users/michael/Github/learn-python3/samples/debug/err.py(4)<module>()
-> print(10 / n)
```

任何时候都可以输入命令p 变量名来查看变量：

```
(Pdb) p s
'0'
(Pdb) p n
0
```

输入命令q结束调试，退出程序：

```
(Pdb) q
```

这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。

### pdb.set_trace()


这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个`pdb.set_trace()`，就可以设置一个断点：

```
# err.py
import pdb

s = '0'
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)
```

运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：

```
$ python3 err.py 
> /Users/michael/Github/learn-python3/samples/debug/err.py(7)<module>()
-> print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File "err.py", line 7, in <module>
    print(10 / n)
ZeroDivisionError: division by zero
```

这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。

### IDE

如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。

### 小结

写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。
虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。

---

# 十五、IO编程 {#IOOperation}

## 读文件

使用Python内置的`open()`函数，传入`文件名`和`标示符`：

```
>>> f = open('/Users/michael/test.txt', 'r')
```

若文件不存在，`open()`函数就会抛出一个`IOError`的错误，并且给出`错误码`和`详细的信息`告诉你文件不存在：

```
>>> f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
```

---

## 读取
文件打开成功后，调用`read()`方法可以一次读取文件的全部内容，Python把内容读到`内存`，用一个`str对象`表示：

```
>>> f.read()
'Hello, world!'
```

## 关闭文件
```
>>>f.close()
```

由于文件读写时都有可能产生`IOError`，一旦出错，后面的`f.close()`就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用`try ... finally`来实现：

```
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```

使用`with`:

```
with open('/path/to/file', 'r') as f:
    print(f.read())
```

`read()`会一次性读取文件的全部内容，如果文件过大，容易塞满内存。

保险起见，可以反复调用``read(size)`方法，每次最多读取`size个字节`的内容。

另外，调用`readline()`可以每次读取一行内容，

调用`readlines()`一次读取所有内容并按行返回`list`。

---

## file-like Object

像`open()`函数返回的这种有个`read()`方法的对象，在Python中统称为`file-like Object`。除了file外，还可以是`内存的字节流`，`网络流`，`自定义流`等等。`file-like Object`不要求从特定类继承，只要写个`read()`方法就行。
`StringIO`就是在内存中创建的`file-like Object`，常用作临时缓冲。

---

## 二进制文件
要读取二进制文件，比如图片、视频等等，用`'rb'`模式打开文件即可：

```
>>> f = open('/Users/michael/test.jpg', 'rb')
>>> f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
```
---

## 字符编码
要读取非UTF-8编码的文本文件，需要给`open()`函数传入`encoding`参数，例如，读取GBK编码的文件：

```
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
>>> f.read()
'测试'
```

遇到有些编码不规范的文件，你可能会遇到`UnicodeDecodeError`，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，`open()`函数还接收一个`errors`参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：

```
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
```

---

## 写文件
写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符`'w'`或者`'wb'`表示写文本文件或写二进制文件：

```
>>> f = open('/Users/michael/test.txt', 'w')
>>> f.write('Hello, world!')
>>> f.close()
```

你可以反复调用`write()`来写入文件，但是务必要调用`f.close()`来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到`内存`缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：

```
with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
```

要写入特定编码的文本文件，请给`open()`函数传入`encoding`参数，将字符串自动转换成指定编码。

---

## StringIO和BytesIO

### StringIO

在内存中读写str。
要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入：

```
>>> from io import StringIO
>>> f = StringIO()
>>> f.write('hello')
5
>>> f.write(' ')
1
>>> f.write('world!')
6
>>> print(f.getvalue())
hello world!
```

`getvalue()`方法用于获得写入后的`str`。
要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：

```
>>> from io import StringIO
>>> f = StringIO('Hello!\nHi!\nGoodbye!')
>>> while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!
```

---

### BytesIO

操作`二进制数据`，就需要使用`BytesIO`。
`BytesIO`实现了在`内存`中读写`bytes`，我们创建一个`BytesIO`，然后写入一些`bytes`：

```
>>> from io import BytesIO
>>> f = BytesIO()
>>> f.write('中文'.encode('utf-8'))
6
>>> print(f.getvalue())
b'\xe4\xb8\xad\xe6\x96\x87'
```

请注意，写入的不是`str`，而是经过`UTF-8编码`的`bytes`。
和`StringIO`类似，可以用一个`bytes`初始化`BytesIO`，然后，像读文件一样读取：

```
>>> from io import BytesIO
>>> f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
>>> f.read()
b'\xe4\xb8\xad\xe6\x96\x87'
```

---

## os模块
Python内置的os模块也可以直接调用操作系统提供的接口函数。
打开Python交互式命令行，我们来看看如何使用os模块的基本功能：

```
>>> import os
>>> os.name # 操作系统类型
'posix'
```

如果是`posix`，说明系统是`Linux、Unix或Mac OS X`，如果是`nt`，就是`Windows`系统。
要获取详细的系统信息，可以调用`uname()`函数：

```
>>> os.uname()
posix.uname_result(sysname='Darwin', nodename='MichaelMacPro.local', release='14.3.0', version='Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64', machine='x86_64')
```

注意`uname()`函数在Windows上不提供，也就是说，`os模块`的某些函数是`跟操作系统相关`的。

---

### 环境变量
在操作系统中定义的环境变量，全部保存在`os.environ`这个变量中，可以直接查看：

```
>>> os.environ
environ({'VERSIONER_PYTHON_PREFER_32_BIT': 'no', 'TERM_PROGRAM_VERSION': '326', 'LOGNAME': 'michael', 'USER': 'michael', 'PATH': '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin', ...})
```

要获取某个环境变量的值，可以调用os.environ.get('key')`：

```
>>> os.environ.get('PATH')
'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin'
>>> os.environ.get('x', 'default')
'default'
```
`

---

### 操作文件和目录
操作文件和目录的函数一部分放在`os模块`中，一部分放在`os.path模块`中，这一点要注意一下。查看、创建和删除目录可以这么调用：

```
# 查看当前目录的绝对路径:
>>> os.path.abspath('.')
'/Users/michael'
# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
>>> os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
# 然后创建一个目录:
>>> os.mkdir('/Users/michael/testdir')
# 删掉一个目录:
>>> os.rmdir('/Users/michael/testdir')
```

把两个路径合成一个时，`不要直接拼`字符串，而要通过`os.path.join()`函数，这样可以正确处理不同操作系统的`路径分隔符`。在`Linux/Unix/Mac`下，`os.path.join()`返回这样的字符串：

`part-1/part-2`

而Windows下会返回这样的字符串：

`part-1\part-2`

要拆分路径时，也不要直接去拆字符串，而要通过`os.path.split()`函数，这样可以把一个路径拆分为两部分，后一部分总是`最后级别的目录或文件名`：

```
>>> os.path.split('/Users/michael/testdir/file.txt')
('/Users/michael/testdir', 'file.txt')
os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：
>>> os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
```

这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对`字符串`进行操作。
文件操作使用下面的函数。假定当前目录下有一个test.txt文件：

```
# 对文件重命名:
>>> os.rename('test.txt', 'test.py')
# 删掉文件:
>>> os.remove('test.py')
```

但是复制文件的函数居然在os模块中不存在，原因是复制文件`并非`由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。

幸运的是`shutil模块`提供了`copyfile()`的函数，你还可以在`shutil模块`中找到很多实用函数，它们可以看做是`os模块的补充`。
最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：

```
>>> [x for x in os.listdir('.') if os.path.isdir(x)]
['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]
```

要列出所有的.py文件，也只需一行代码：

```
>>> [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']
['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py']
```

---

## 序列化
我们把变量从`内存`中变成`可存储或传输`的过程称之为`序列化`，在Python中叫`picklin`g，在其他语言中也被称之为`serialization，marshalling，flattening`等等。

序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。

反过来，把变量内容从序列化的对象重新读到内存里称之为`反序列化`，即`unpickling`。
Python提供了`pickle模块`来实现序列化。
首先，我们尝试把一个对象序列化并写入文件：

```
>>> import pickle
>>> d = dict(name='Bob', age=20, score=88)
>>> pickle.dumps(d)
b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
```

`pickle.dumps()`方法把任意对象序列化成一个`bytes`，然后，就可以把这个`bytes`写入文件。或者用另一个方法`pickle.dump()`直接把对象序列化后写入一个`file-like Object`：

```
>>> f = open('dump.txt', 'wb')
>>> pickle.dump(d, f)
>>> f.close()
```

看看写入的`dump.txt`文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。
当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用`pickle.loads()`方法反序列化出对象，也可以直接用`pickle.load()`方法从一个`file-like Object`中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：

```
>>> f = open('dump.txt', 'rb')
>>> d = pickle.load(f)
>>> f.close()
>>> d
{'age': 20, 'score': 88, 'name': 'Bob'}
```

当然，这个变量和原来的变量是完全不相干的对象，它们只是`内容相同`而已。
`Pickle`的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。

---

## JSON

如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为`标准格式`，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个`字符串`，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且`比XML更快`，而且可以直接在Web页面中读取，非常方便。

JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：

JSON类型|Python类型
---|---
{}|dict
[]|list
"string"|str
1234.56|int或float
true/false|True/False
null|None

Python内置的json模块提供了非常完善的`Python对象`到`JSON格式`的转换。我们先看看如何把Python对象变成一个JSON：

```
>>> import json
>>> d = dict(name='Bob', age=20, score=88)
>>> json.dumps(d)
'{"age": 20, "score": 88, "name": "Bob"}'
```

`dumps()`方法返回一个`str`，内容就是`标准的JSON`。类似的，`dump()`方法可以直接把`JSON`写入一个`file-like Object`。
要把JSON反序列化为Python对象，用`loads()`或者对应的`load()`方法，前者把JSON的字符串反序列化，后者从`file-like Object`中读取字符串并反序列化：

```
>>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
>>> json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
```

由于JSON标准规定JSON编码是`UTF-8`，所以我们总是能正确地在Python的str与JSON的字符串之间转换。

---

## JSON进阶

Python的`dict对象`可以直接序列化为JSON的`{}`，不过，很多时候，我们更喜欢用`class`表示`对象`，比如定义Student类，然后序列化：

```
import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student('Bob', 20, 88)
print(json.dumps(s))
```

运行代码，毫不留情地得到一个`TypeError`：

```
Traceback (most recent call last):
  ...
TypeError: <__main__.Student object at 0x10603cc50> is not JSON serializable
```

错误的原因是Student对象`不是`一个可序列化为JSON的对象。
如果连class的实例对象都无法序列化为JSON，这肯定不合理！
别急，我们仔细看看`dumps()`方法的参数列表，可以发现，除了第一个必须的obj参数外，`dumps()`方法还提供了一大堆的可选参数：  

[https://docs.python.org/3/library/json.html#json.dumps  
](https://docs.python.org/3/library/json.html#json.dumps)

这些可选参数就是让我们来`定制JSON序列化`。前面的代码之所以无法把Student类实例序列化为JSON，是因为默认情况下，`dumps()`方法不知道如何将Student实例变为一个JSON的`{}对象`。

可选参数`default`就是把`任意一个对象`变成一个`可序列为JSON的对象`，我们只需要为Student专门写一个`转换函数`，再把函数传进去即可：

```
def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
```

这样，`Student实例`首先被`student2dict()`函数转换成`dict`，然后再被顺利序列化为`JSON`：

```
>>> print(json.dumps(s, default=student2dict))
{"age": 20, "name": "Bob", "score": 88}
```

不过，下次如果遇到一个`Teacher类`的实例，照样无法序列化为`JSON`。我们可以偷个懒，把任意class的实例变为dict：

```
print(json.dumps(s, default=lambda obj: obj.__dict__))
```

因为通常class的实例都有一个`__dict__`属性，它就是一个`dict`，用来存储实例变量。也有少数例外，比如定义了`__slots__`的`class`。

同样的道理，如果我们要把JSON反序列化为一个`Student`对象实例，`loads()`方法首先转换出一个`dict`对象，然后，我们传入的`object_hook`函数负责把`dict`转换为`Student`实例：

```
def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
```

运行结果如下：

```
>>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
>>> print(json.loads(json_str, object_hook=dict2student))
<__main__.Student object at 0x10cd3c190>
```

打印出的是反序列化的`Student实例对象`。

---

